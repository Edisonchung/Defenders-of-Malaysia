<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Defenders of Malaysia</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .game-container {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 15px;
            box-shadow: 0 0 30px #00ffff88, inset 0 0 30px #00ffff22;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
        }

        @media (max-width: 768px) {
            .game-container {
                border-radius: 0;
                border: none;
                max-width: 100vw;
                max-height: 100vh;
                width: 100vw;
                height: 100vh;
            }
        }

        canvas {
            display: block;
            border-radius: 12px;
            background: radial-gradient(ellipse at center, #001122 0%, #000811 100%);
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            canvas {
                border-radius: 0;
            }
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
            flex-wrap: wrap;
        }

        @media (max-width: 480px) {
            .ui-overlay {
                padding: 5px;
            }
        }

        .score, .lives, .level {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
            backdrop-filter: blur(5px);
            margin: 2px;
        }

        @media (max-width: 480px) {
            .score, .lives, .level {
                padding: 4px 8px;
                font-size: 12px;
            }
        }

        .start-screen, .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px 20px;
            box-shadow: 0 0 50px #00ffff88;
            backdrop-filter: blur(10px);
            max-width: 90%;
            width: 400px;
        }

        @media (max-width: 480px) {
            .start-screen, .game-over {
                padding: 20px 15px;
                width: 95%;
                border-radius: 10px;
            }
        }

        .start-screen h2, .game-over h2 {
            font-size: 36px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #00ffff;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        @media (max-width: 480px) {
            .start-screen h2, .game-over h2 {
                font-size: 24px;
                margin-bottom: 10px;
            }
        }

        .start-screen p, .game-over p {
            font-size: 16px;
            margin-bottom: 20px;
            color: #aaaaff;
        }

        @media (max-width: 480px) {
            .start-screen p, .game-over p {
                font-size: 14px;
                margin-bottom: 15px;
            }
        }

        .start-btn, .restart-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            border-radius: 25px;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
            touch-action: manipulation;
        }

        @media (max-width: 480px) {
            .start-btn, .restart-btn {
                padding: 12px 24px;
                font-size: 16px;
                letter-spacing: 1px;
            }
        }

        .start-btn:hover, .restart-btn:hover,
        .start-btn:active, .restart-btn:active {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.6);
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 12px;
            color: #888;
            max-width: 90%;
        }

        @media (max-width: 768px) {
            .controls {
                bottom: 10px;
                font-size: 10px;
            }
        }

        /* Mobile Touch Controls */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            pointer-events: auto;
            z-index: 20;
            display: none;
        }

        @media (max-width: 768px), (max-height: 500px) {
            .mobile-controls {
                display: block;
            }
        }

        @media (min-width: 769px) and (min-height: 501px) {
            .mobile-controls {
                display: none !important;
            }
        }

        .joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            touch-action: none;
        }

        .joystick-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #00ffff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .fire-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 0, 0.2);
            border: 3px solid rgba(255, 255, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ffff00;
            font-weight: bold;
            touch-action: manipulation;
            user-select: none;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }

        .fire-button:active {
            background: rgba(255, 255, 0, 0.4);
            transform: scale(0.95);
        }

        .pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            cursor: pointer;
            pointer-events: auto;
            z-index: 30;
            touch-action: manipulation;
        }

        .pause-btn:active {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Orientation message */
        .orientation-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            text-align: center;
            padding: 20px;
        }

        .orientation-message h3 {
            color: #00ffff;
            font-size: 24px;
            margin-bottom: 20px;
        }

        .orientation-message p {
            color: #aaaaff;
            font-size: 16px;
        }

        .rotate-icon {
            font-size: 48px;
            margin: 20px 0;
            animation: rotate 2s infinite linear;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @media screen and (orientation: portrait) and (max-width: 768px) {
            .orientation-message {
                display: flex;
            }
            .game-container {
                display: none;
            }
        }

        /* Haptic feedback class */
        .haptic-active {
            animation: vibrate 0.1s;
        }

        @keyframes vibrate {
            0% { transform: translate(0); }
            20% { transform: translate(-1px, 1px); }
            40% { transform: translate(-1px, -1px); }
            60% { transform: translate(1px, 1px); }
            80% { transform: translate(1px, -1px); }
            100% { transform: translate(0); }
        }
    </style>
</head>
<body>
    <div class="orientation-message">
        <h3>üá≤üáæ Defenders of Malaysia üá≤üáæ</h3>
        <div class="rotate-icon">üì±</div>
        <p>Please rotate your device to landscape mode for the best gaming experience!</p>
        <p style="margin-top: 15px; font-size: 14px;">Sila putar peranti anda ke mod landskap untuk pengalaman permainan terbaik!</p>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="ui-overlay">
            <div class="score">Score: <span id="scoreValue">0</span></div>
            <div class="level">Level: <span id="levelValue">1</span></div>
            <div class="lives">Lives: <span id="livesValue">3</span></div>
            <div class="level">Wave: <span id="waveValue">1</span></div>
        </div>

        <button class="pause-btn" id="pauseButton">‚è∏</button>

        <div id="startScreen" class="start-screen">
            <h2>DEFENDERS OF MALAYSIA</h2>
            <p>üá≤üáæ Protect the homeland from alien invasion! üá≤üáæ</p>
            <p>Defend Kuala Lumpur and all of Malaysia!</p>
            <p class="desktop-controls" style="display: block;">Use WASD or Arrow Keys to move, SPACE to shoot</p>
            <p class="mobile-controls-text" style="display: none;">Use virtual joystick to move, tap fire button to shoot</p>
            <button class="start-btn" id="startButton">MULA MISI!</button>
        </div>

        <div id="gameOverScreen" class="game-over" style="display: none;">
            <h2>MALAYSIA TERANCAM!</h2>
            <p>The Twin Towers have fallen...</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button class="restart-btn" id="restartButton">CUBA LAGI!</button>
        </div>

        <div class="mobile-controls">
            <div class="joystick-area" id="joystick">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
            <div class="fire-button" id="fireButton">üî•</div>
        </div>

        <div class="controls">
            <p class="desktop-controls" style="display: block;">WASD / Arrow Keys: Move | SPACE: Fire | ESC: Pause</p>
            <p class="mobile-controls-text" style="display: none;">Virtual Joystick: Move | Fire Button: Shoot | ‚è∏: Pause</p>
            <p style="margin-top: 10px; color: #FFD700;">üá≤üáæ Mempertahankan Malaysia dari pencerobohan asing! üá≤üáæ</p>
        </div>
    </div>

    <script>
        // Mobile detection - better detection for all devices
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         (window.innerWidth <= 768) || 
                         ('ontouchstart' in window && window.innerHeight < window.innerWidth);
        
        // Get canvas and context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Mobile-responsive canvas sizing
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const rect = container.getBoundingClientRect();
            canvas.width = Math.floor(rect.width);
            canvas.height = Math.floor(rect.height);
            
            // Adjust game scaling for mobile
            if (isMobile) {
                gameScale = Math.min(canvas.width / 800, canvas.height / 600);
            } else {
                gameScale = 1;
            }
        }

        let gameScale = 1;
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state variables
        let gameState = 'start';
        let score = 0;
        let lives = 3;
        let level = 1;
        let enemySpeed = 1;
        let enemySpawnRate = 0.02;
        let wave = 1;
        let enemiesInWave = 0;
        let maxEnemiesPerWave = 8;
        let bossActive = false;
        let stateMessage = "";
        let stateMessageTimer = 0;
        let gamePhase = 'preparation';

        // Game objects
        let player = {};
        let bullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];
        let landmarks = [];
        let bosses = [];
        let powerUps = [];

        // Input handling
        const keys = {};
        let lastShotTime = 0;
        const shotCooldown = 150;

        // Mobile touch controls
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickMovement = { x: 0, y: 0 };
        let fireButtonPressed = false;

        // Initialize mobile controls
        function initMobileControls() {
            // Check if we should use mobile controls
            const shouldUseMobile = isMobile || window.innerWidth <= 768 || window.innerHeight < 500;
            
            if (shouldUseMobile) {
                document.querySelectorAll('.desktop-controls').forEach(el => el.style.display = 'none');
                document.querySelectorAll('.mobile-controls-text').forEach(el => el.style.display = 'block');
                
                // Force mobile controls to be visible
                const mobileControlsDiv = document.querySelector('.mobile-controls');
                if (mobileControlsDiv) {
                    mobileControlsDiv.style.display = 'block';
                }
            } else {
                document.querySelectorAll('.desktop-controls').forEach(el => el.style.display = 'block');
                document.querySelectorAll('.mobile-controls-text').forEach(el => el.style.display = 'none');
                return; // Don't set up mobile controls on desktop
            }

            const joystick = document.getElementById('joystick');
            const joystickKnob = document.getElementById('joystickKnob');
            const fireButton = document.getElementById('fireButton');

            // Joystick controls
            function handleJoystickStart(e) {
                e.preventDefault();
                joystickActive = true;
                const rect = joystick.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
                
                // Add haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            }

            function handleJoystickMove(e) {
                if (!joystickActive) return;
                e.preventDefault();
                
                const touch = e.touches ? e.touches[0] : e;
                const deltaX = touch.clientX - joystickCenter.x;
                const deltaY = touch.clientY - joystickCenter.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = 30;

                if (distance <= maxDistance) {
                    joystickMovement.x = deltaX / maxDistance;
                    joystickMovement.y = deltaY / maxDistance;
                    joystickKnob.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                } else {
                    const angle = Math.atan2(deltaY, deltaX);
                    const limitedX = Math.cos(angle) * maxDistance;
                    const limitedY = Math.sin(angle) * maxDistance;
                    joystickMovement.x = limitedX / maxDistance;
                    joystickMovement.y = limitedY / maxDistance;
                    joystickKnob.style.transform = `translate(${limitedX}px, ${limitedY}px)`;
                }
            }

            function handleJoystickEnd(e) {
                e.preventDefault();
                joystickActive = false;
                joystickMovement.x = 0;
                joystickMovement.y = 0;
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }

            // Touch events for joystick
            joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystick.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystick.addEventListener('touchend', handleJoystickEnd, { passive: false });

            // Mouse events for desktop testing (only if not mobile)
            if (!shouldUseMobile) {
                joystick.addEventListener('mousedown', handleJoystickStart);
                document.addEventListener('mousemove', handleJoystickMove);
                document.addEventListener('mouseup', handleJoystickEnd);
            }

            // Fire button
            function handleFireStart(e) {
                e.preventDefault();
                fireButtonPressed = true;
                fireButton.classList.add('haptic-active');
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(30);
                }
                
                setTimeout(() => fireButton.classList.remove('haptic-active'), 100);
            }

            function handleFireEnd(e) {
                e.preventDefault();
                fireButtonPressed = false;
            }

            fireButton.addEventListener('touchstart', handleFireStart, { passive: false });
            fireButton.addEventListener('touchend', handleFireEnd, { passive: false });
            
            // Mouse events for desktop testing (only if not mobile)
            if (!shouldUseMobile) {
                fireButton.addEventListener('mousedown', handleFireStart);
                fireButton.addEventListener('mouseup', handleFireEnd);
            }
        }

        // Initialize game
        function initGame() {
            // Player setup - scale for mobile
            player = {
                x: canvas.width / 2,
                y: canvas.height - 80 * gameScale,
                width: 40 * gameScale,
                height: 40 * gameScale,
                speed: 5 * gameScale,
                color: '#00ffff'
            };

            // Clear arrays
            bullets = [];
            enemies = [];
            particles = [];
            stars = [];
            landmarks = [];
            bosses = [];
            powerUps = [];

            // Create starfield
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: (Math.random() * 2 + 1) * gameScale,
                    speed: (Math.random() * 0.5 + 0.5) * gameScale
                });
            }

            // Create Malaysian landmarks with health - scale for mobile
            landmarks = [
                { 
                    name: 'Twin Towers', 
                    x: 150 * gameScale, 
                    y: canvas.height - 200 * gameScale, 
                    width: 40 * gameScale, 
                    height: 180 * gameScale, 
                    color: '#C0C0C0', 
                    health: 100, 
                    maxHealth: 100 
                },
                { 
                    name: 'KL Tower', 
                    x: 350 * gameScale, 
                    y: canvas.height - 150 * gameScale, 
                    width: 20 * gameScale, 
                    height: 130 * gameScale, 
                    color: '#DAA520', 
                    health: 100, 
                    maxHealth: 100 
                },
                { 
                    name: 'Sultan Abdul Samad', 
                    x: 550 * gameScale, 
                    y: canvas.height - 100 * gameScale, 
                    width: 80 * gameScale, 
                    height: 80 * gameScale, 
                    color: '#8B4513', 
                    health: 100, 
                    maxHealth: 100 
                },
                { 
                    name: 'KLCC', 
                    x: 700 * gameScale, 
                    y: canvas.height - 120 * gameScale, 
                    width: 60 * gameScale, 
                    height: 100 * gameScale, 
                    color: '#4169E1', 
                    health: 100, 
                    maxHealth: 100 
                }
            ];

            // Reset game variables
            score = 0;
            lives = 3;
            level = 1;
            wave = 1;
            enemiesInWave = 0;
            maxEnemiesPerWave = 8;
            enemySpeed = 1 * gameScale;
            enemySpawnRate = 0.02;
            bossActive = false;
            gamePhase = 'preparation';
            showMessage("Prepare for Malaysian Defense!", 3000);
            updateUI();
        }

        // Draw player with mobile scaling
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.scale(gameScale, gameScale);
            
            // Malaysian fighter jet with flag colors
            ctx.fillStyle = '#CC0000';
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-15, 20);
            ctx.lineTo(-5, 15);
            ctx.lineTo(0, 10);
            ctx.lineTo(5, 15);
            ctx.lineTo(15, 20);
            ctx.closePath();
            ctx.fill();

            // Blue stripe
            ctx.fillStyle = '#003893';
            ctx.fillRect(-12, -5, 24, 6);

            // Gold star
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-3, -8, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Engine glow
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.ellipse(0, 18, 8, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Outline
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -20);
            ctx.lineTo(-15, 20);
            ctx.lineTo(-5, 15);
            ctx.lineTo(0, 10);
            ctx.lineTo(5, 15);
            ctx.lineTo(15, 20);
            ctx.closePath();
            ctx.stroke();
            
            ctx.restore();
        }

        // Update player with mobile controls
        function updatePlayer() {
            let moveX = 0;
            let moveY = 0;

            // Desktop controls
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                moveX -= 1;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                moveX += 1;
            }
            if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                moveY -= 1;
            }
            if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                moveY += 1;
            }

            // Mobile controls - check for active joystick movement
            const shouldUseMobile = isMobile || window.innerWidth <= 768 || window.innerHeight < 500;
            if (shouldUseMobile && (Math.abs(joystickMovement.x) > 0.1 || Math.abs(joystickMovement.y) > 0.1)) {
                moveX = joystickMovement.x;
                moveY = joystickMovement.y;
            }

            // Apply movement
            player.x += moveX * player.speed;
            player.y += moveY * player.speed;

            // Keep player in bounds
            player.x = Math.max(20 * gameScale, Math.min(canvas.width - 20 * gameScale, player.x));
            player.y = Math.max(20 * gameScale, Math.min(canvas.height - 20 * gameScale, player.y));

            // Shooting
            const shouldShoot = keys[' '] || (shouldUseMobile && fireButtonPressed);
            if (shouldShoot && Date.now() - lastShotTime > shotCooldown) {
                shoot();
                lastShotTime = Date.now();
            }
        }

        // Shooting with mobile scaling
        function shoot() {
            bullets.push({
                x: player.x,
                y: player.y - 10 * gameScale,
                width: 4 * gameScale,
                height: 12 * gameScale,
                speed: 8 * gameScale,
                color: '#ffff00'
            });
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.y -= bullet.speed;

                if (bullet.y < 0) {
                    bullets.splice(i, 1);
                }
            }
        }

        // Draw bullets
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.shadowColor = bullet.color;
                ctx.shadowBlur = 10 * gameScale;
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                ctx.shadowBlur = 0;
            });
        }

        // Enhanced wave and boss system
        function checkGamePhase() {
            if (score < 1000) {
                gamePhase = 'preparation';
            } else if (score < 3000) {
                gamePhase = 'invasion';
            } else if (score < 6000) {
                gamePhase = 'crisis';
            } else {
                gamePhase = 'final';
            }
        }

        function spawnBoss() {
            if (wave % 5 === 0 && !bossActive && enemies.length === 0) {
                bossActive = true;
                const bossNames = [
                    'Alien Datuk', 'Space Sultan', 'Cosmic Raja', 'Galactic Tun',
                    'Dark Dato', 'Shadow Tengku', 'Void Tan Sri', 'Final Emperor'
                ];
                const bossIndex = Math.min(Math.floor(wave / 5) - 1, bossNames.length - 1);
                
                bosses.push({
                    x: canvas.width / 2,
                    y: -100 * gameScale,
                    width: (80 + (bossIndex * 20)) * gameScale,
                    height: (60 + (bossIndex * 15)) * gameScale,
                    speed: 0.8 * gameScale,
                    health: 100 + (bossIndex * 50),
                    maxHealth: 100 + (bossIndex * 50),
                    color: '#ff0066',
                    name: bossNames[bossIndex],
                    shootTimer: 0,
                    points: 200 + (bossIndex * 100)
                });
                
                showMessage(`BOSS WAVE: ${bossNames[bossIndex]}`, 4000);
            }
        }

        function updateBosses() {
            for (let i = bosses.length - 1; i >= 0; i--) {
                const boss = bosses[i];
                
                if (boss.y < 80 * gameScale) {
                    boss.y += boss.speed;
                } else {
                    boss.x += Math.sin(Date.now() * 0.002) * 2 * gameScale;
                    boss.x = Math.max(boss.width/2, Math.min(canvas.width - boss.width/2, boss.x));
                }
                
                boss.shootTimer++;
                if (boss.shootTimer > 90) {
                    boss.shootTimer = 0;
                    // Boss shoots multiple bullets
                    for (let j = 0; j < 3; j++) {
                        enemies.push({
                            x: boss.x + (j - 1) * 25 * gameScale,
                            y: boss.y + 30 * gameScale,
                            width: 12 * gameScale,
                            height: 12 * gameScale,
                            speed: 2.5 * gameScale,
                            color: '#ff3366',
                            points: 5,
                            type: 'boss_bullet'
                        });
                    }
                }
            }
        }

        function drawBosses() {
            bosses.forEach(boss => {
                ctx.save();
                ctx.translate(boss.x, boss.y);
                ctx.scale(gameScale, gameScale);
                
                // Boss ship
                ctx.fillStyle = boss.color;
                ctx.shadowColor = boss.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(0, -25);
                ctx.lineTo(-boss.width/(2*gameScale), 20);
                ctx.lineTo(-boss.width/(4*gameScale), 30);
                ctx.lineTo(boss.width/(4*gameScale), 30);
                ctx.lineTo(boss.width/(2*gameScale), 20);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Boss details
                ctx.fillStyle = '#990033';
                ctx.fillRect(-boss.width/(3*gameScale), -5, boss.width/(1.5*gameScale), 15);
                
                ctx.restore();
                
                // Boss health bar
                const healthPercentage = boss.health / boss.maxHealth;
                ctx.fillStyle = '#333';
                ctx.fillRect(boss.x - 40 * gameScale, boss.y - 50 * gameScale, 80 * gameScale, 6 * gameScale);
                ctx.fillStyle = healthPercentage > 0.5 ? '#ff0000' : '#990000';
                ctx.fillRect(boss.x - 40 * gameScale, boss.y - 50 * gameScale, 80 * gameScale * healthPercentage, 6 * gameScale);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(boss.x - 40 * gameScale, boss.y - 50 * gameScale, 80 * gameScale, 6 * gameScale);
                
                // Boss name
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${14 * gameScale}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(boss.name, boss.x, boss.y - 60 * gameScale);
            });
        }

        function showMessage(message, duration = 2000) {
            stateMessage = message;
            stateMessageTimer = duration;
        }

        function updateStateMessage() {
            if (stateMessageTimer > 0) {
                stateMessageTimer -= 16;
            }
        }

        function drawStateMessage() {
            if (stateMessageTimer > 0) {
                ctx.save();
                ctx.fillStyle = `rgba(255, 215, 0, ${Math.min(1, stateMessageTimer / 500)})`;
                ctx.font = `bold ${24 * gameScale}px Arial`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#003893';
                ctx.lineWidth = 2;
                ctx.strokeText(stateMessage, canvas.width / 2, canvas.height / 2 - 100 * gameScale);
                ctx.fillText(stateMessage, canvas.width / 2, canvas.height / 2 - 100 * gameScale);
                ctx.restore();
            }
        }

        function checkWaveCompletion() {
            if (enemies.length === 0 && !bossActive && enemiesInWave >= maxEnemiesPerWave) {
                wave++;
                enemiesInWave = 0;
                maxEnemiesPerWave = Math.min(15, 8 + Math.floor(wave * 1.2));
                
                const malaysianStates = [
                    'Kuala Lumpur Secure!', 'Selangor Protected!', 'Johor Defended!',
                    'Penang Safe!', 'Perak Secured!', 'Sabah Protected!', 'Sarawak Defended!',
                    'Kelantan Safe!', 'Terengganu Secured!', 'Pahang Protected!',
                    'Negeri Sembilan Defended!', 'Melaka Safe!', 'Kedah Secured!',
                    'Perlis Protected!', 'Malaysia United!'
                ];
                
                const stateIndex = Math.min(wave - 1, malaysianStates.length - 1);
                showMessage(`Wave ${wave}: ${malaysianStates[stateIndex]}`, 3000);
                
                // Wave completion bonus
                score += 50 + (wave * 10);
                
                // Heal landmarks slightly
                landmarks.forEach(landmark => {
                    landmark.health = Math.min(landmark.maxHealth, landmark.health + 10);
                });
                
                // Check for boss spawn
                spawnBoss();
            }
        }

        // Spawn enemies with wave system
        function spawnEnemy() {
            if (Math.random() < enemySpawnRate && !bossActive && enemiesInWave < maxEnemiesPerWave) {
                const types = ['basic', 'fast', 'heavy', 'zigzag'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let enemy = {
                    x: Math.random() * (canvas.width - 40 * gameScale) + 20 * gameScale,
                    y: -30 * gameScale,
                    width: 30 * gameScale,
                    height: 30 * gameScale,
                    type: type,
                    zigzagDirection: 1,
                    zigzagTimer: 0
                };

                switch(type) {
                    case 'basic':
                        enemy.speed = enemySpeed;
                        enemy.color = '#ff4444';
                        enemy.points = 15;
                        break;
                    case 'fast':
                        enemy.speed = enemySpeed * 1.6;
                        enemy.color = '#ff8844';
                        enemy.points = 25;
                        enemy.width = 25 * gameScale;
                        enemy.height = 25 * gameScale;
                        break;
                    case 'heavy':
                        enemy.speed = enemySpeed * 0.7;
                        enemy.color = '#8844ff';
                        enemy.points = 40;
                        enemy.width = 40 * gameScale;
                        enemy.height = 40 * gameScale;
                        break;
                    case 'zigzag':
                        enemy.speed = enemySpeed * 0.9;
                        enemy.color = '#44ff88';
                        enemy.points = 30;
                        break;
                }

                enemies.push(enemy);
                enemiesInWave++;
            }
        }

        // Update enemies with enhanced patterns
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Enhanced movement patterns
                if (enemy.type === 'zigzag') {
                    enemy.zigzagTimer++;
                    if (enemy.zigzagTimer > 25) {
                        enemy.zigzagDirection *= -1;
                        enemy.zigzagTimer = 0;
                    }
                    enemy.x += enemy.zigzagDirection * 3 * gameScale;
                }
                
                enemy.y += enemy.speed;

                if (enemy.y > canvas.height) {
                    enemies.splice(i, 1);
                    
                    if (enemy.type !== 'boss_bullet') {
                        lives--;
                        const hitLandmark = landmarks[Math.floor(Math.random() * landmarks.length)];
                        const damage = enemy.type === 'heavy' ? 25 : 15;
                        hitLandmark.health = Math.max(0, hitLandmark.health - damage);
                        createExplosion(hitLandmark.x, hitLandmark.y, '#ff4444');
                        showMessage(`${hitLandmark.name} Under Attack!`, 1500);
                        
                        // Mobile haptic feedback
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(200);
                        }
                        
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                }
            }
        }

        // Draw enemies with enhanced graphics
        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.scale(gameScale, gameScale);
                
                ctx.fillStyle = enemy.color;
                ctx.shadowColor = enemy.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                
                if (enemy.type === 'basic') {
                    ctx.moveTo(0, -15);
                    ctx.lineTo(-15, 15);
                    ctx.lineTo(15, 15);
                } else if (enemy.type === 'fast') {
                    ctx.moveTo(0, -12);
                    ctx.lineTo(-12, 0);
                    ctx.lineTo(0, 12);
                    ctx.lineTo(12, 0);
                } else if (enemy.type === 'heavy') {
                    ctx.rect(-20, -15, 40, 30);
                } else if (enemy.type === 'zigzag') {
                    // Star shape
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 144 - 90) * Math.PI / 180;
                        const x = Math.cos(angle) * 12;
                        const y = Math.sin(angle) * 12;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                } else if (enemy.type === 'boss_bullet') {
                    ctx.rect(-6, -6, 12, 12);
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            });
        }

        // Enhanced collision detection
        function checkCollisions() {
            // Bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Check regular enemy collisions
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (bullet.x > enemy.x - enemy.width/2 &&
                        bullet.x < enemy.x + enemy.width/2 &&
                        bullet.y > enemy.y - enemy.height/2 &&
                        bullet.y < enemy.y + enemy.height/2) {
                        
                        createExplosion(enemy.x, enemy.y, enemy.color);
                        score += enemy.points;
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        
                        // Mobile haptic feedback for hits
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                        break;
                    }
                }
                
                // Check boss collisions
                for (let j = bosses.length - 1; j >= 0; j--) {
                    const boss = bosses[j];
                    
                    if (bullet.x > boss.x - boss.width/2 &&
                        bullet.x < boss.x + boss.width/2 &&
                        bullet.y > boss.y - boss.height/2 &&
                        bullet.y < boss.y + boss.height/2) {
                        
                        boss.health -= 10;
                        createExplosion(bullet.x, bullet.y, '#ffff00');
                        bullets.splice(i, 1);
                        
                        // Mobile haptic feedback
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(30);
                        }
                        
                        if (boss.health <= 0) {
                            createExplosion(boss.x, boss.y, boss.color);
                            score += boss.points;
                            bosses.splice(j, 1);
                            bossActive = false;
                            showMessage(`${boss.name} DEFEATED!`, 3000);
                            
                            // Boss defeat bonus
                            score += 100;
                            
                            // Strong haptic feedback for boss defeat
                            if (isMobile && navigator.vibrate) {
                                navigator.vibrate([200, 100, 200]);
                            }
                        }
                        break;
                    }
                }
            }

            // Player-enemy collisions
            enemies.forEach((enemy, index) => {
                const dist = Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2);
                if (dist < 25 * gameScale) {
                    createExplosion(enemy.x, enemy.y, enemy.color);
                    createExplosion(player.x, player.y, player.color);
                    enemies.splice(index, 1);
                    lives--;
                    
                    // Strong haptic feedback for player hit
                    if (isMobile && navigator.vibrate) {
                        navigator.vibrate(300);
                    }
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            });

            // Player-boss collisions
            bosses.forEach((boss, index) => {
                const dist = Math.sqrt((player.x - boss.x) ** 2 + (player.y - boss.y) ** 2);
                if (dist < 40 * gameScale) {
                    createExplosion(player.x, player.y, player.color);
                    lives--;
                    
                    // Strong haptic feedback
                    if (isMobile && navigator.vibrate) {
                        navigator.vibrate(400);
                    }
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            });
        }

        // Particle explosion with mobile scaling
        function createExplosion(x, y, color) {
            for (let i = 0; i < 12; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8 * gameScale,
                    vy: (Math.random() - 0.5) * 8 * gameScale,
                    life: 30,
                    color: color,
                    size: (Math.random() * 4 + 2) * gameScale
                });
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                p.size *= 0.95;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // Stars background
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }

        function drawStars() {
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // Draw landmarks with health indicators and mobile scaling
        function drawLandmarks() {
            landmarks.forEach(landmark => {
                ctx.save();
                ctx.globalAlpha = 0.7;
                const healthPercentage = landmark.health / landmark.maxHealth;
                const baseColor = healthPercentage > 0.7 ? landmark.color : 
                                 healthPercentage > 0.3 ? '#888888' : '#444444';
                ctx.fillStyle = baseColor;
                
                if (landmark.name === 'Twin Towers') {
                    // Twin towers
                    ctx.fillRect(landmark.x - 8 * gameScale, landmark.y, 16 * gameScale, landmark.height);
                    ctx.fillRect(landmark.x + 8 * gameScale, landmark.y, 16 * gameScale, landmark.height);
                    // Sky bridge
                    ctx.fillRect(landmark.x - 8 * gameScale, landmark.y + 80 * gameScale, 32 * gameScale, 4 * gameScale);
                    // Windows
                    ctx.fillStyle = healthPercentage > 0.3 ? '#FFD700' : '#666';
                    for (let i = 0; i < 8; i++) {
                        ctx.fillRect(landmark.x - 6 * gameScale, landmark.y + i * 20 * gameScale, 2 * gameScale, 2 * gameScale);
                        ctx.fillRect(landmark.x + 10 * gameScale, landmark.y + i * 20 * gameScale, 2 * gameScale, 2 * gameScale);
                    }
                } else if (landmark.name === 'KL Tower') {
                    // Tower body
                    ctx.fillRect(landmark.x - 5 * gameScale, landmark.y, 10 * gameScale, landmark.height);
                    // Tower top
                    ctx.beginPath();
                    ctx.arc(landmark.x, landmark.y - 10 * gameScale, 15 * gameScale, 0, Math.PI * 2);
                    ctx.fill();
                } else if (landmark.name === 'Sultan Abdul Samad') {
                    // Main building
                    ctx.fillRect(landmark.x - landmark.width/2, landmark.y, landmark.width, landmark.height);
                    // Clock tower
                    ctx.fillRect(landmark.x - 8 * gameScale, landmark.y - 40 * gameScale, 16 * gameScale, 40 * gameScale);
                    // Dome
                    ctx.fillStyle = healthPercentage > 0.5 ? '#32CD32' : '#228B22';
                    ctx.beginPath();
                    ctx.arc(landmark.x, landmark.y - 40 * gameScale, 12 * gameScale, 0, Math.PI);
                    ctx.fill();
                } else if (landmark.name === 'KLCC') {
                    // Modern building
                    ctx.fillRect(landmark.x - landmark.width/2, landmark.y, landmark.width, landmark.height);
                    // Windows
                    ctx.fillStyle = healthPercentage > 0.3 ? '#87CEEB' : '#666';
                    for (let i = 0; i < 6; i++) {
                        ctx.fillRect(landmark.x - 25 * gameScale + i * 8 * gameScale, landmark.y + 10 * gameScale, 6 * gameScale, 4 * gameScale);
                        ctx.fillRect(landmark.x - 25 * gameScale + i * 8 * gameScale, landmark.y + 30 * gameScale, 6 * gameScale, 4 * gameScale);
                        ctx.fillRect(landmark.x - 25 * gameScale + i * 8 * gameScale, landmark.y + 50 * gameScale, 6 * gameScale, 4 * gameScale);
                    }
                }
                
                // Health bar
                if (landmark.health < landmark.maxHealth) {
                    const barWidth = Math.max(landmark.width, 40 * gameScale);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(landmark.x - barWidth/2, landmark.y - 20 * gameScale, barWidth, 4 * gameScale);
                    ctx.fillStyle = healthPercentage > 0.7 ? '#00ff00' : 
                                   healthPercentage > 0.3 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(landmark.x - barWidth/2, landmark.y - 20 * gameScale, barWidth * healthPercentage, 4 * gameScale);
                }
                
                ctx.restore();
            });
        }

        // Enhanced level progression
        function checkLevelUp() {
            const newLevel = Math.floor(score / 1500) + 1;
            if (newLevel > level) {
                level = newLevel;
                enemySpeed += 0.2 * gameScale;
                enemySpawnRate = Math.min(0.04, enemySpawnRate + 0.003);
                
                // Major milestone rewards
                if (level === 5) {
                    showMessage("üá≤üáæ SELANGOR LIBERATED! üá≤üáæ", 4000);
                } else if (level === 10) {
                    showMessage("üá≤üáæ PENINSULAR MALAYSIA SECURE! üá≤üáæ", 4000);
                } else if (level === 15) {
                    showMessage("üá≤üáæ EAST MALAYSIA DEFENDED! üá≤üáæ", 4000);
                } else if (level === 20) {
                    showMessage("üá≤üáæ FINAL ASSAULT - DEFEND PUTRAJAYA! üá≤üáæ", 5000);
                } else {
                    showMessage(`Level ${level} - Malaysia Stronger!`, 2000);
                }
                
                createExplosion(canvas.width / 2, 100 * gameScale, '#FFD700');
                
                // Level bonus
                score += level * 50;
                
                // Heal landmarks on major levels
                if (level % 5 === 0) {
                    landmarks.forEach(landmark => {
                        landmark.health = landmark.maxHealth;
                    });
                }
                
                // Haptic feedback for level up
                if (isMobile && navigator.vibrate) {
                    navigator.vibrate([100, 50, 100, 50, 100]);
                }
            }
        }

        // Update UI with wave info
        function updateUI() {
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('livesValue').textContent = lives;
            document.getElementById('levelValue').textContent = level;
            document.getElementById('waveValue').textContent = wave;
        }

        // Victory condition
        function checkVictory() {
            if (score >= 15000 && level >= 20) {
                gameState = 'victory';
                showMessage("üá≤üáæ MALAYSIA VICTORIOUS! üá≤üáæ", 10000);
                
                // Victory haptic feedback
                if (isMobile && navigator.vibrate) {
                    navigator.vibrate([300, 100, 300, 100, 300, 100, 500]);
                }
                
                setTimeout(() => {
                    const gameOverScreen = document.getElementById('gameOverScreen');
                    gameOverScreen.querySelector('h2').textContent = 'MALAYSIA BERJAYA!';
                    gameOverScreen.querySelector('p').textContent = 'You have successfully defended the homeland!';
                    gameOverScreen.style.display = 'block';
                }, 3000);
            }
        }

        // Enhanced game loop
        function gameLoop() {
            if (gameState !== 'playing') return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update
            updateStars();
            updatePlayer();
            updateBullets();
            spawnEnemy();
            updateEnemies();
            updateBosses();
            updateParticles();
            updateStateMessage();
            checkCollisions();
            checkLevelUp();
            checkWaveCompletion();
            checkGamePhase();
            checkVictory();
            updateUI();

            // Draw
            drawStars();
            drawLandmarks();
            drawPlayer();
            drawBullets();
            drawEnemies();
            drawBosses();
            drawParticles();
            drawStateMessage();

            requestAnimationFrame(gameLoop);
        }

        // Game control functions
        function startGame() {
            console.log('Starting game...'); // Debug log
            gameState = 'playing';
            document.getElementById('startScreen').style.display = 'none';
            initGame();
            
            // Always try to initialize mobile controls on small screens
            const shouldUseMobile = isMobile || window.innerWidth <= 768 || window.innerHeight < 500;
            console.log('Should use mobile:', shouldUseMobile); // Debug log
            if (shouldUseMobile) {
                initMobileControls();
            }
            
            gameLoop();
        }

        function gameOver() {
            console.log('Game over...'); // Debug log
            gameState = 'gameOver';
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOverScreen').style.display = 'block';
            
            // Game over haptic feedback
            if (isMobile && navigator.vibrate) {
                navigator.vibrate([500, 200, 500]);
            }
        }

        function restartGame() {
            console.log('Restarting game...'); // Debug log
            document.getElementById('gameOverScreen').style.display = 'none';
            startGame();
        }

        function togglePause() {
            console.log('Toggle pause...'); // Debug log
            if (gameState === 'playing') {
                gameState = 'paused';
                showMessage("GAME PAUSED", 99999);
            } else if (gameState === 'paused') {
                gameState = 'playing';
                stateMessageTimer = 0;
                gameLoop();
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') {
                togglePause();
            }
            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Prevent zoom on mobile
        document.addEventListener('gesturestart', function (e) {
            e.preventDefault();
        });

        document.addEventListener('touchstart', function (e) {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });

        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);

        // Initialize game on load
        function initializeGame() {
            initGame();
            
            // Set up button event listeners
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            const pauseButton = document.getElementById('pauseButton');
            
            if (startButton) {
                startButton.addEventListener('click', startGame);
                startButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    startGame();
                });
            }
            
            if (restartButton) {
                restartButton.addEventListener('click', restartGame);
                restartButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    restartGame();
                });
            }
            
            if (pauseButton) {
                pauseButton.addEventListener('click', togglePause);
                pauseButton.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    togglePause();
                });
            }
            
            // Auto-detect and show appropriate controls
            const shouldUseMobile = isMobile || window.innerWidth <= 768 || window.innerHeight < 500;
            if (shouldUseMobile) {
                document.querySelectorAll('.desktop-controls').forEach(el => el.style.display = 'none');
                document.querySelectorAll('.mobile-controls-text').forEach(el => el.style.display = 'block');
                // Force mobile controls div to be visible
                const mobileControlsDiv = document.querySelector('.mobile-controls');
                if (mobileControlsDiv) {
                    mobileControlsDiv.style.display = 'block';
                }
            } else {
                document.querySelectorAll('.desktop-controls').forEach(el => el.style.display = 'block');
                document.querySelectorAll('.mobile-controls-text').forEach(el => el.style.display = 'none');
            }
            
            // Mobile-specific initialization
            if (shouldUseMobile) {
                // Lock screen orientation if possible
                if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock('landscape').catch(() => {
                        console.log('Screen orientation lock not supported');
                    });
                }
            }
        }

        // Call initialization when page loads
        initializeGame();
    </script>
</body>
</html>
