<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defenders of Malaysia - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 15px;
            box-shadow: 0 0 30px #00ffff88, inset 0 0 30px #00ffff22;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
        }

        canvas {
            display: block;
            border-radius: 12px;
            background: radial-gradient(ellipse at center, #001122 0%, #000811 100%);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .score, .lives, .level, .wave, .powerup-indicator {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
            backdrop-filter: blur(5px);
            margin: 2px;
        }

        .ui-left, .ui-center, .ui-right {
            display: flex;
            flex-direction: column;
        }

        .start-screen, .game-over, .pause-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 0 50px #00ffff88;
            backdrop-filter: blur(10px);
            z-index: 100;
        }

        .start-screen h2, .game-over h2, .pause-screen h2 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ffff;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .start-screen p, .game-over p, .pause-screen p {
            font-size: 18px;
            margin-bottom: 20px;
            color: #aaaaff;
        }

        .start-btn, .restart-btn, .resume-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            border-radius: 25px;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
            margin: 10px;
        }

        .start-btn:hover, .restart-btn:hover, .resume-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.6);
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            color: #888;
        }

        .combo-display {
            position: absolute;
            top: 50%;
            left: 20px;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #FFD700;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .difficulty-selector {
            margin: 20px 0;
        }

        .difficulty-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #00ffff;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover, .difficulty-btn.selected {
            background: rgba(0, 255, 255, 0.3);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="900" height="700"></canvas>
        
        <div class="ui-overlay">
            <div class="ui-left">
                <div class="score">Score: <span id="scoreValue">0</span></div>
                <div class="lives">Lives: <span id="livesValue">3</span></div>
                <div class="powerup-indicator" id="powerupIndicator" style="display: none;">
                    Power-up: <span id="powerupType">None</span>
                </div>
            </div>
            <div class="ui-center">
                <div class="level">Level: <span id="levelValue">1</span></div>
                <div class="wave">Wave: <span id="waveValue">1</span></div>
            </div>
            <div class="ui-right">
                <div class="score">High Score: <span id="highScoreValue">0</span></div>
                <div class="score">Combo: <span id="comboValue">0</span>x</div>
            </div>
        </div>

        <div class="combo-display" id="comboDisplay">COMBO!</div>

        <div id="startScreen" class="start-screen">
            <h2>DEFENDERS OF MALAYSIA</h2>
            <p>ðŸ‡²ðŸ‡¾ Protect the homeland from alien invasion! ðŸ‡²ðŸ‡¾</p>
            <p>Defend Kuala Lumpur and all of Malaysia!</p>
            
            <div class="difficulty-selector">
                <p>Choose Difficulty:</p>
                <button class="difficulty-btn selected" onclick="selectDifficulty('normal')">Normal</button>
                <button class="difficulty-btn" onclick="selectDifficulty('hard')">Hard</button>
                <button class="difficulty-btn" onclick="selectDifficulty('nightmare')">Nightmare</button>
            </div>
            
            <p>Use WASD or Arrow Keys to move, SPACE to shoot</p>
            <p>Collect power-ups and chain combos for high scores!</p>
            <button class="start-btn" onclick="startGame()">MULA MISI!</button>
        </div>

        <div id="pauseScreen" class="pause-screen" style="display: none;">
            <h2>GAME PAUSED</h2>
            <p>Take a break, defender!</p>
            <button class="resume-btn" onclick="resumeGame()">Resume</button>
            <button class="restart-btn" onclick="restartGame()">Restart</button>
        </div>

        <div id="gameOverScreen" class="game-over" style="display: none;">
            <h2>MALAYSIA TERANCAM!</h2>
            <p>The Twin Towers have fallen...</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Highest Combo: <span id="highestCombo">0</span>x</p>
            <button class="restart-btn" onclick="restartGame()">CUBA LAGI!</button>
        </div>

        <div class="controls">
            <p>WASD / Arrow Keys: Move | SPACE: Fire | ESC: Pause | R: Special Attack</p>
            <p style="margin-top: 10px; color: #FFD700;">ðŸ‡²ðŸ‡¾ Mempertahankan Malaysia dari pencerobohan asing! ðŸ‡²ðŸ‡¾</p>
        </div>
    </div>

    <script>
        // Enhanced game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameState = 'start';
        let score = 0;
        let highScore = localStorage.getItem('malaysiaDef_highScore') || 0;
        let lives = 3;
        let level = 1;
        let wave = 1;
        let difficulty = 'normal';
        let combo = 0;
        let comboTimer = 0;
        let maxCombo = 0;

        // Enhanced game mechanics
        let enemySpeed = 1;
        let enemySpawnRate = 0.02;
        let enemiesInWave = 0;
        let maxEnemiesPerWave = 8;
        let bossActive = false;
        let specialAttackCooldown = 0;
        let specialAttackReady = true;

        // Visual effects
        let stateMessage = "";
        let stateMessageTimer = 0;
        let screenShake = 0;
        let gamePhase = 'preparation';

        // Game objects
        let player = {};
        let bullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];
        let landmarks = [];
        let bosses = [];
        let powerUps = [];
        let backgroundObjects = [];

        // Enhanced input handling
        const keys = {};
        let lastShotTime = 0;
        const shotCooldown = 120;

        // Difficulty settings
        const difficultySettings = {
            normal: { enemySpeedMult: 1, spawnRateMult: 1, enemyHealthMult: 1 },
            hard: { enemySpeedMult: 1.3, spawnRateMult: 1.4, enemyHealthMult: 1.2 },
            nightmare: { enemySpeedMult: 1.6, spawnRateMult: 1.8, enemyHealthMult: 1.5 }
        };

        // Power-up system
        let activePowerUp = null;
        let powerUpTimer = 0;

        function selectDifficulty(diff) {
            difficulty = diff;
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }

        function initGame() {
            // Enhanced player setup
            player = {
                x: canvas.width / 2,
                y: canvas.height - 80,
                width: 40,
                height: 40,
                speed: 6,
                color: '#00ffff',
                shield: 0,
                weaponLevel: 1
            };

            // Clear arrays
            bullets = [];
            enemies = [];
            particles = [];
            stars = [];
            landmarks = [];
            bosses = [];
            powerUps = [];
            backgroundObjects = [];

            // Enhanced starfield
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    speed: Math.random() * 1 + 0.5,
                    twinkle: Math.random() * 100
                });
            }

            // Background nebula objects
            for (let i = 0; i < 5; i++) {
                backgroundObjects.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 100 + 50,
                    color: `hsl(${Math.random() * 60 + 180}, 50%, 20%)`,
                    speed: Math.random() * 0.2 + 0.1
                });
            }

            // Enhanced landmarks with detailed graphics
            landmarks = [
                { 
                    name: 'Petronas Twin Towers', 
                    x: 180, y: canvas.height - 220, 
                    width: 50, height: 200, 
                    color: '#C0C0C0', 
                    health: 150, maxHealth: 150,
                    type: 'towers'
                },
                { 
                    name: 'KL Tower', 
                    x: 380, y: canvas.height - 170, 
                    width: 25, height: 150, 
                    color: '#DAA520', 
                    health: 120, maxHealth: 120,
                    type: 'tower'
                },
                { 
                    name: 'Sultan Abdul Samad Building', 
                    x: 580, y: canvas.height - 120, 
                    width: 90, height: 100, 
                    color: '#8B4513', 
                    health: 100, maxHealth: 100,
                    type: 'historic'
                },
                { 
                    name: 'KLCC Park', 
                    x: 750, y: canvas.height - 80, 
                    width: 80, height: 60, 
                    color: '#228B22', 
                    health: 80, maxHealth: 80,
                    type: 'park'
                }
            ];

            // Reset enhanced variables
            score = 0;
            lives = 3;
            level = 1;
            wave = 1;
            combo = 0;
            maxCombo = 0;
            comboTimer = 0;
            enemiesInWave = 0;
            maxEnemiesPerWave = 8;
            enemySpeed = 1;
            enemySpawnRate = 0.02;
            bossActive = false;
            gamePhase = 'preparation';
            activePowerUp = null;
            powerUpTimer = 0;
            specialAttackCooldown = 0;
            specialAttackReady = true;
            
            showMessage("ðŸ‡²ðŸ‡¾ Prepare for Malaysian Defense! ðŸ‡²ðŸ‡¾", 3000);
            updateUI();
        }

        function drawEnhancedPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Player shield effect
            if (player.shield > 0) {
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(0, 0, 35, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
            
            // Enhanced Malaysian fighter jet
            const gradient = ctx.createLinearGradient(-20, -20, 20, 20);
            gradient.addColorStop(0, '#CC0000');
            gradient.addColorStop(0.3, '#FFFFFF');
            gradient.addColorStop(0.6, '#003893');
            gradient.addColorStop(1, '#FFD700');
            
            ctx.fillStyle = gradient;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            
            // Main body
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(-18, 20);
            ctx.lineTo(-8, 18);
            ctx.lineTo(0, 12);
            ctx.lineTo(8, 18);
            ctx.lineTo(18, 20);
            ctx.closePath();
            ctx.fill();
            
            // Wings detail
            ctx.fillStyle = '#003893';
            ctx.fillRect(-15, 5, 30, 8);
            
            // Cockpit
            ctx.fillStyle = '#87CEEB';
            ctx.beginPath();
            ctx.ellipse(0, -10, 6, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Malaysian flag star and crescent
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-5, -12, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Engine glow
            ctx.fillStyle = `hsl(${Math.random() * 60}, 100%, 60%)`;
            ctx.beginPath();
            ctx.ellipse(0, 22, 12, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Weapon upgrades visual
            if (player.weaponLevel > 1) {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-20, 0, 4, 12);
                ctx.fillRect(16, 0, 4, 12);
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function updatePlayer() {
            // Enhanced movement with momentum
            const moveSpeed = player.speed + (activePowerUp === 'speed' ? 2 : 0);
            
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
                player.x = Math.max(25, player.x - moveSpeed);
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D']) {
                player.x = Math.min(canvas.width - 25, player.x + moveSpeed);
            }
            if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                player.y = Math.max(25, player.y - moveSpeed);
            }
            if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                player.y = Math.min(canvas.height - 25, player.y + moveSpeed);
            }

            // Enhanced shooting
            if (keys[' '] && Date.now() - lastShotTime > shotCooldown) {
                shoot();
                lastShotTime = Date.now();
            }

            // Special attack
            if (keys['r'] || keys['R']) {
                if (specialAttackReady && specialAttackCooldown <= 0) {
                    specialAttack();
                    specialAttackCooldown = 300; // 5 seconds at 60fps
                    specialAttackReady = false;
                }
            }

            // Update shield
            if (player.shield > 0) {
                player.shield--;
            }

            // Update special attack cooldown
            if (specialAttackCooldown > 0) {
                specialAttackCooldown--;
                if (specialAttackCooldown <= 0) {
                    specialAttackReady = true;
                }
            }
        }

        function shoot() {
            const shotCount = player.weaponLevel;
            const spread = player.weaponLevel > 1 ? 15 : 0;
            
            for (let i = 0; i < shotCount; i++) {
                const angle = (i - (shotCount - 1) / 2) * spread * Math.PI / 180;
                bullets.push({
                    x: player.x + Math.sin(angle) * 10,
                    y: player.y - 15,
                    vx: Math.sin(angle) * 3,
                    vy: -8 - (activePowerUp === 'rapid' ? 2 : 0),
                    width: 6,
                    height: 15,
                    color: activePowerUp === 'power' ? '#ff0000' : '#ffff00',
                    damage: activePowerUp === 'power' ? 2 : 1,
                    trail: []
                });
            }
        }

        function specialAttack() {
            // Screen-clearing special attack
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                bullets.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    width: 8,
                    height: 8,
                    color: '#ff00ff',
                    damage: 3,
                    special: true,
                    trail: []
                });
            }
            
            screenShake = 20;
            showMessage("SPECIAL ATTACK!", 1000);
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Add trail effect
                bullet.trail.push({ x: bullet.x, y: bullet.y });
                if (bullet.trail.length > 5) {
                    bullet.trail.shift();
                }
                
                bullet.x += bullet.vx || 0;
                bullet.y += bullet.vy || -8;

                if (bullet.y < -20 || bullet.x < -20 || bullet.x > canvas.width + 20) {
                    bullets.splice(i, 1);
                }
            }
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                // Draw trail
                for (let i = 0; i < bullet.trail.length; i++) {
                    const alpha = (i + 1) / bullet.trail.length * 0.5;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = bullet.color;
                    const trail = bullet.trail[i];
                    ctx.fillRect(trail.x - 2, trail.y, 4, 8);
                }
                ctx.globalAlpha = 1;
                
                // Draw bullet
                ctx.fillStyle = bullet.color;
                ctx.shadowColor = bullet.color;
                ctx.shadowBlur = 15;
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                ctx.shadowBlur = 0;
            });
        }

        function spawnPowerUp(x, y) {
            if (Math.random() < 0.3) { // 30% chance
                const types = ['rapid', 'power', 'shield', 'speed', 'weapon'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                powerUps.push({
                    x: x,
                    y: y,
                    type: type,
                    color: getPowerUpColor(type),
                    size: 20,
                    rotation: 0,
                    speed: 2
                });
            }
        }

        function getPowerUpColor(type) {
            const colors = {
                rapid: '#ff6600',
                power: '#ff0000',
                shield: '#00ffff',
                speed: '#00ff00',
                weapon: '#ff00ff'
            };
            return colors[type];
        }

        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;
                powerUp.rotation += 0.1;
                
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                const dist = Math.sqrt((player.x - powerUp.x) ** 2 + (player.y - powerUp.y) ** 2);
                if (dist < 25) {
                    activatePowerUp(powerUp.type);
                    powerUps.splice(i, 1);
                    createExplosion(powerUp.x, powerUp.y, powerUp.color);
                }
            }
            
            // Update active power-up timer
            if (activePowerUp && powerUpTimer > 0) {
                powerUpTimer--;
                if (powerUpTimer <= 0) {
                    activePowerUp = null;
                    updateUI();
                }
            }
        }

        function activatePowerUp(type) {
            activePowerUp = type;
            powerUpTimer = 300; // 5 seconds
            
            switch (type) {
                case 'rapid':
                    showMessage("RAPID FIRE!", 1000);
                    break;
                case 'power':
                    showMessage("POWER SHOT!", 1000);
                    break;
                case 'shield':
                    player.shield = 180; // 3 seconds
                    showMessage("SHIELD ACTIVATED!", 1000);
                    break;
                case 'speed':
                    showMessage("SPEED BOOST!", 1000);
                    break;
                case 'weapon':
                    player.weaponLevel = Math.min(3, player.weaponLevel + 1);
                    showMessage("WEAPON UPGRADE!", 1000);
                    powerUpTimer = 0; // Permanent upgrade
                    activePowerUp = null;
                    break;
            }
            updateUI();
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                ctx.save();
                ctx.translate(powerUp.x, powerUp.y);
                ctx.rotate(powerUp.rotation);
                
                ctx.fillStyle = powerUp.color;
                ctx.shadowColor = powerUp.color;
                ctx.shadowBlur = 20;
                
                // Draw power-up icon based on type
                switch (powerUp.type) {
                    case 'rapid':
                        ctx.fillRect(-8, -8, 16, 16);
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-2, -6, 4, 12);
                        break;
                    case 'power':
                        ctx.beginPath();
                        ctx.arc(0, 0, 10, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'shield':
                        ctx.beginPath();
                        ctx.moveTo(0, -12);
                        ctx.lineTo(-8, 8);
                        ctx.lineTo(8, 8);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'speed':
                        ctx.beginPath();
                        ctx.moveTo(-10, 0);
                        ctx.lineTo(10, -5);
                        ctx.lineTo(10, 5);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'weapon':
                        ctx.fillRect(-10, -3, 20, 6);
                        ctx.fillRect(-3, -10, 6, 20);
                        break;
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        function spawnEnemy() {
            const settings = difficultySettings[difficulty];
            const adjustedSpawnRate = enemySpawnRate * settings.spawnRateMult;
            
            if (Math.random() < adjustedSpawnRate && !bossActive && enemiesInWave < maxEnemiesPerWave) {
                const types = ['basic', 'fast', 'heavy', 'zigzag', 'spinner'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let enemy = {
                    x: Math.random() * (canvas.width - 60) + 30,
                    y: -40,
                    width: 35,
                    height: 35,
                    type: type,
                    zigzagDirection: 1,
                    zigzagTimer: 0,
                    rotation: 0,
                    health: Math.floor(1 * settings.enemyHealthMult),
                    maxHealth: Math.floor(1 * settings.enemyHealthMult),
                    trail: []
                };

                switch(type) {
                    case 'basic':
                        enemy.speed = enemySpeed * settings.enemySpeedMult;
                        enemy.color = '#ff4444';
                        enemy.points = 15;
                        break;
                    case 'fast':
                        enemy.speed = enemySpeed * 1.8 * settings.enemySpeedMult;
                        enemy.color = '#ff8844';
                        enemy.points = 25;
                        enemy.width = 28;
                        enemy.height = 28;
                        break;
                    case 'heavy':
                        enemy.speed = enemySpeed * 0.6 * settings.enemySpeedMult;
                        enemy.color = '#8844ff';
                        enemy.points = 50;
                        enemy.width = 45;
                        enemy.height = 45;
                        enemy.health = Math.floor(3 * settings.enemyHealthMult);
                        enemy.maxHealth = Math.floor(3 * settings.enemyHealthMult);
                        break;
                    case 'zigzag':
                        enemy.speed = enemySpeed * 1.1 * settings.enemySpeedMult;
                        enemy.color = '#44ff88';
                        enemy.points = 35;
                        break;
                    case 'spinner':
                        enemy.speed = enemySpeed * 0.8 * settings.enemySpeedMult;
                        enemy.color = '#ff44ff';
                        enemy.points = 40;
                        enemy.health = Math.floor(2 * settings.enemyHealthMult);
                        enemy.maxHealth = Math.floor(2 * settings.enemyHealthMult);
                        break;
                }

                enemies.push(enemy);
                enemiesInWave++;
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Add trail
                enemy.trail.push({ x: enemy.x, y: enemy.y });
                if (enemy.trail.length > 3) {
                    enemy.trail.shift();
                }
                
                // Enhanced movement patterns
                switch (enemy.type) {
                    case 'zigzag':
                        enemy.zigzagTimer++;
                        if (enemy.zigzagTimer > 20) {
                            enemy.zigzagDirection *= -1;
                            enemy.zigzagTimer = 0;
                        }
                        enemy.x += enemy.zigzagDirection * 4;
                        break;
                    case 'spinner':
                        enemy.rotation += 0.2;
                        enemy.x += Math.sin(enemy.y * 0.02) * 2;
                        break;
                    case 'boss_bullet':
                        enemy.x += enemy.vx || 0;
                        break;
                }
                
                enemy.y += enemy.speed;

                if (enemy.y > canvas.height + 50) {
                    enemies.splice(i, 1);
                    
                    if (enemy.type !== 'boss_bullet') {
                        lives--;
                        damageRandomLandmark(enemy);
                        
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                }
            }
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                // Draw trail
                for (let i = 0; i < enemy.trail.length; i++) {
                    const alpha = (i + 1) / enemy.trail.length * 0.3;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = enemy.color;
                    const trail = enemy.trail[i];
                    ctx.fillRect(trail.x - 5, trail.y - 5, 10, 10);
                }
                ctx.globalAlpha = 1;
                
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.rotate(enemy.rotation);
                
                ctx.fillStyle = enemy.color;
                ctx.shadowColor = enemy.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                
                switch (enemy.type) {
                    case 'basic':
                        ctx.moveTo(0, -18);
                        ctx.lineTo(-15, 18);
                        ctx.lineTo(15, 18);
                        break;
                    case 'fast':
                        for (let i = 0; i < 3; i++) {
                            const angle = (i * 120) * Math.PI / 180;
                            const x = Math.cos(angle) * 15;
                            const y = Math.sin(angle) * 15;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        break;
                    case 'heavy':
                        ctx.rect(-22, -18, 44, 36);
                        break;
                    case 'zigzag':
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 72) * Math.PI / 180;
                            const x = Math.cos(angle) * 15;
                            const y = Math.sin(angle) * 15;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        break;
                    case 'spinner':
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * 60) * Math.PI / 180;
                            const x = Math.cos(angle) * (i % 2 ? 10 : 18);
                            const y = Math.sin(angle) * (i % 2 ? 10 : 18);
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        break;
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Health bar for tougher enemies
                if (enemy.health > 1 && enemy.health < enemy.maxHealth) {
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-15, -25, 30, 4);
                    ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : '#ff0000';
                    ctx.fillRect(-15, -25, 30 * healthPercent, 4);
                }
                
                ctx.restore();
            });
        }

        function damageRandomLandmark(enemy) {
            const hitLandmark = landmarks[Math.floor(Math.random() * landmarks.length)];
            const damage = enemy.type === 'heavy' ? 35 : 20;
            hitLandmark.health = Math.max(0, hitLandmark.health - damage);
            createExplosion(hitLandmark.x, hitLandmark.y, '#ff4444');
            showMessage(`${hitLandmark.name} Under Attack!`, 1500);
            screenShake = 10;
        }

        function checkCollisions() {
            // Enhanced bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (bullet.x > enemy.x - enemy.width/2 &&
                        bullet.x < enemy.x + enemy.width/2 &&
                        bullet.y > enemy.y - enemy.height/2 &&
                        bullet.y < enemy.y + enemy.height/2) {
                        
                        enemy.health -= bullet.damage || 1;
                        createExplosion(enemy.x, enemy.y, enemy.color);
                        bullets.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            score += enemy.points;
                            combo++;
                            comboTimer = 120; // 2 seconds
                            maxCombo = Math.max(maxCombo, combo);
                            
                            // Combo score bonus
                            if (combo > 5) {
                                score += combo * 2;
                                showComboEffect();
                            }
                            
                            spawnPowerUp(enemy.x, enemy.y);
                            enemies.splice(j, 1);
                        }
                        break;
                    }
                }
                
                // Check boss collisions
                for (let j = bosses.length - 1; j >= 0; j--) {
                    const boss = bosses[j];
                    
                    if (bullet.x > boss.x - boss.width/2 &&
                        bullet.x < boss.x + boss.width/2 &&
                        bullet.y > boss.y - boss.height/2 &&
                        bullet.y < boss.y + boss.height/2) {
                        
                        boss.health -= bullet.damage || 1;
                        createExplosion(bullet.x, bullet.y, '#ffff00');
                        bullets.splice(i, 1);
                        screenShake = 5;
                        
                        if (boss.health <= 0) {
                            createExplosion(boss.x, boss.y, boss.color);
                            score += boss.points;
                            combo += 5; // Big combo bonus for boss
                            bosses.splice(j, 1);
                            bossActive = false;
                            showMessage(`ðŸŽ‰ ${boss.name} DEFEATED! ðŸŽ‰`, 3000);
                            screenShake = 30;
                            
                            // Boss defeat rewards
                            score += 500;
                            spawnPowerUp(boss.x, boss.y);
                            spawnPowerUp(boss.x - 30, boss.y);
                            spawnPowerUp(boss.x + 30, boss.y);
                        }
                        break;
                    }
                }
            }

            // Enhanced player-enemy collisions with shield
            if (player.shield <= 0) {
                enemies.forEach((enemy, index) => {
                    const dist = Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2);
                    if (dist < 30) {
                        createExplosion(enemy.x, enemy.y, enemy.color);
                        createExplosion(player.x, player.y, player.color);
                        enemies.splice(index, 1);
                        lives--;
                        screenShake = 15;
                        combo = 0; // Reset combo on hit
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                });
            }
        }

        function updateCombo() {
            if (comboTimer > 0) {
                comboTimer--;
            } else if (combo > 0) {
                combo = 0;
            }
        }

        function showComboEffect() {
            const comboDisplay = document.getElementById('comboDisplay');
            comboDisplay.textContent = `${combo}x COMBO!`;
            comboDisplay.style.opacity = '1';
            setTimeout(() => {
                comboDisplay.style.opacity = '0';
            }, 1000);
        }

        function createExplosion(x, y, color) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 40,
                    color: color,
                    size: Math.random() * 6 + 2,
                    gravity: 0.1
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.98;
                p.vy += p.gravity || 0;
                p.life--;
                p.size *= 0.97;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life / 40;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                star.twinkle += 0.1;
                if (star.y > canvas.height) {
                    star.y = -10;
                    star.x = Math.random() * canvas.width;
                }
            });
        }

        function drawEnhancedBackground() {
            // Draw nebula objects
            backgroundObjects.forEach(obj => {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = obj.color;
                ctx.beginPath();
                ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                obj.y += obj.speed;
                if (obj.y > canvas.height + obj.size) {
                    obj.y = -obj.size;
                    obj.x = Math.random() * canvas.width;
                }
            });
            
            // Enhanced stars with twinkling
            stars.forEach(star => {
                const alpha = 0.5 + Math.sin(star.twinkle) * 0.3;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function drawEnhancedLandmarks() {
            landmarks.forEach(landmark => {
                ctx.save();
                const healthPercentage = landmark.health / landmark.maxHealth;
                const damage = 1 - healthPercentage;
                
                ctx.globalAlpha = Math.max(0.4, 1 - damage * 0.6);
                
                // Enhanced landmark graphics
                if (landmark.type === 'towers') {
                    // Enhanced Twin Towers
                    const gradient = ctx.createLinearGradient(landmark.x - 25, 0, landmark.x + 25, 0);
                    gradient.addColorStop(0, landmark.color);
                    gradient.addColorStop(0.5, '#E0E0E0');
                    gradient.addColorStop(1, landmark.color);
                    ctx.fillStyle = gradient;
                    
                    // Tower 1
                    ctx.fillRect(landmark.x - 20, landmark.y, 18, landmark.height);
                    // Tower 2
                    ctx.fillRect(landmark.x + 2, landmark.y, 18, landmark.height);
                    // Sky bridge
                    ctx.fillRect(landmark.x - 20, landmark.y + landmark.height * 0.4, 40, 6);
                    
                    // Windows
                    ctx.fillStyle = healthPercentage > 0.5 ? '#FFD700' : (healthPercentage > 0.2 ? '#888' : '#444');
                    for (let floor = 0; floor < 20; floor++) {
                        for (let window = 0; window < 3; window++) {
                            if (Math.random() > damage) {
                                ctx.fillRect(landmark.x - 18 + window * 6, landmark.y + floor * 9, 3, 4);
                                ctx.fillRect(landmark.x + 4 + window * 6, landmark.y + floor * 9, 3, 4);
                            }
                        }
                    }
                    
                    // Spires
                    ctx.fillStyle = landmark.color;
                    ctx.fillRect(landmark.x - 12, landmark.y - 15, 4, 15);
                    ctx.fillRect(landmark.x + 8, landmark.y - 15, 4, 15);
                }
                
                // Health indicator
                if (landmark.health < landmark.maxHealth) {
                    const barWidth = Math.max(landmark.width, 50);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(landmark.x - barWidth/2, landmark.y - 30, barWidth, 6);
                    ctx.fillStyle = healthPercentage > 0.7 ? '#00ff00' : 
                                   healthPercentage > 0.3 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(landmark.x - barWidth/2, landmark.y - 30, barWidth * healthPercentage, 6);
                    
                    // Landmark name
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(landmark.name, landmark.x, landmark.y - 35);
                }
                
                ctx.restore();
            });
        }

        function updateUI() {
            document.getElementById('scoreValue').textContent = score.toLocaleString();
            document.getElementById('livesValue').textContent = lives;
            document.getElementById('levelValue').textContent = level;
            document.getElementById('waveValue').textContent = wave;
            document.getElementById('highScoreValue').textContent = parseInt(highScore).toLocaleString();
            document.getElementById('comboValue').textContent = combo;
            
            // Power-up indicator
            const powerupIndicator = document.getElementById('powerupIndicator');
            if (activePowerUp) {
                powerupIndicator.style.display = 'block';
                document.getElementById('powerupType').textContent = activePowerUp.toUpperCase();
            } else {
                powerupIndicator.style.display = 'none';
            }
        }

        function showMessage(message, duration = 2000) {
            stateMessage = message;
            stateMessageTimer = duration;
        }

        function updateStateMessage() {
            if (stateMessageTimer > 0) {
                stateMessageTimer -= 16;
            }
        }

        function drawStateMessage() {
            if (stateMessageTimer > 0) {
                ctx.save();
                ctx.fillStyle = `rgba(255, 215, 0, ${Math.min(1, stateMessageTimer / 500)})`;
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#003893';
                ctx.lineWidth = 3;
                ctx.strokeText(stateMessage, canvas.width / 2, canvas.height / 2 - 100);
                ctx.fillText(stateMessage, canvas.width / 2, canvas.height / 2 - 100);
                ctx.restore();
            }
        }

        function applyScreenShake() {
            if (screenShake > 0) {
                const shakeX = (Math.random() - 0.5) * screenShake;
                const shakeY = (Math.random() - 0.5) * screenShake;
                ctx.translate(shakeX, shakeY);
                screenShake *= 0.9;
                if (screenShake < 0.1) screenShake = 0;
            }
        }

        function checkWaveCompletion() {
            if (enemies.length === 0 && !bossActive && enemiesInWave >= maxEnemiesPerWave) {
                wave++;
                enemiesInWave = 0;
                maxEnemiesPerWave = Math.min(20, 8 + Math.floor(wave * 1.5));
                
                const malaysianStates = [
                    'Kuala Lumpur Secured!', 'Selangor Protected!', 'Johor Defended!',
                    'Penang Safe!', 'Perak Secured!', 'Sabah Protected!', 'Sarawak Defended!',
                    'Kelantan Safe!', 'Terengganu Secured!', 'Pahang Protected!',
                    'Negeri Sembilan Defended!', 'Melaka Safe!', 'Kedah Secured!',
                    'Perlis Protected!', 'Malaysia United!', 'ASEAN Defended!', 'Southeast Asia Liberated!'
                ];
                
                const stateIndex = Math.min(wave - 1, malaysianStates.length - 1);
                showMessage(`Wave ${wave}: ${malaysianStates[stateIndex]}`, 3000);
                
                score += 100 + (wave * 20);
                
                // Heal landmarks
                landmarks.forEach(landmark => {
                    landmark.health = Math.min(landmark.maxHealth, landmark.health + 25);
                });
                
                spawnBoss();
            }
        }

        function spawnBoss() {
            if (wave % 5 === 0 && !bossActive && enemies.length === 0) {
                bossActive = true;
                const bossNames = [
                    'Alien Datuk', 'Space Sultan', 'Cosmic Raja', 'Galactic Tun',
                    'Dark Dato', 'Shadow Tengku', 'Void Tan Sri', 'Final Emperor'
                ];
                const bossIndex = Math.min(Math.floor(wave / 5) - 1, bossNames.length - 1);
                
                bosses.push({
                    x: canvas.width / 2,
                    y: -120,
                    width: 100 + (bossIndex * 25),
                    height: 80 + (bossIndex * 20),
                    speed: 1.2,
                    health: 150 + (bossIndex * 75),
                    maxHealth: 150 + (bossIndex * 75),
                    color: '#ff0066',
                    name: bossNames[bossIndex],
                    shootTimer: 0,
                    points: 300 + (bossIndex * 150),
                    phase: 1,
                    moveTimer: 0
                });
                
                showMessage(`ðŸš¨ BOSS WAVE: ${bossNames[bossIndex]} ðŸš¨`, 4000);
                screenShake = 25;
            }
        }

        function updateBosses() {
            for (let i = bosses.length - 1; i >= 0; i--) {
                const boss = bosses[i];
                boss.moveTimer++;
                
                // Boss movement phases
                if (boss.y < 100) {
                    boss.y += boss.speed;
                } else {
                    // Phase-based movement
                    switch (boss.phase) {
                        case 1:
                            boss.x += Math.sin(boss.moveTimer * 0.03) * 3;
                            if (boss.moveTimer > 200) {
                                boss.phase = 2;
                                boss.moveTimer = 0;
                            }
                            break;
                        case 2:
                            boss.x += (player.x - boss.x) * 0.01;
                            if (boss.moveTimer > 150) {
                                boss.phase = 1;
                                boss.moveTimer = 0;
                            }
                            break;
                    }
                    boss.x = Math.max(boss.width/2, Math.min(canvas.width - boss.width/2, boss.x));
                }
                
                // Boss shooting patterns
                boss.shootTimer++;
                if (boss.shootTimer > 60) {
                    boss.shootTimer = 0;
                    
                    // Different shooting patterns based on health
                    const healthPercent = boss.health / boss.maxHealth;
                    if (healthPercent > 0.5) {
                        // Phase 1: Triple shot
                        for (let j = 0; j < 3; j++) {
                            enemies.push({
                                x: boss.x + (j - 1) * 30,
                                y: boss.y + 40,
                                width: 15,
                                height: 15,
                                speed: 3,
                                color: '#ff3366',
                                points: 10,
                                type: 'boss_bullet',
                                health: 1,
                                maxHealth: 1,
                                trail: []
                            });
                        }
                    } else {
                        // Phase 2: Spread shot
                        for (let j = 0; j < 5; j++) {
                            const angle = (j - 2) * 0.3;
                            enemies.push({
                                x: boss.x,
                                y: boss.y + 40,
                                width: 12,
                                height: 12,
                                speed: 2.5,
                                vx: Math.sin(angle) * 2,
                                color: '#ff0033',
                                points: 15,
                                type: 'boss_bullet',
                                health: 1,
                                maxHealth: 1,
                                trail: []
                            });
                        }
                    }
                }
            }
        }

        function drawBosses() {
            bosses.forEach(boss => {
                ctx.save();
                ctx.translate(boss.x, boss.y);
                
                // Boss pulsing effect
                const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.1;
                ctx.scale(pulse, pulse);
                
                // Main boss body
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, boss.width/2);
                gradient.addColorStop(0, boss.color);
                gradient.addColorStop(0.7, '#990033');
                gradient.addColorStop(1, '#330011');
                
                ctx.fillStyle = gradient;
                ctx.shadowColor = boss.color;
                ctx.shadowBlur = 25;
                
                // Boss ship design
                ctx.beginPath();
                ctx.moveTo(0, -boss.height/2);
                ctx.lineTo(-boss.width/2, boss.height/3);
                ctx.lineTo(-boss.width/3, boss.height/2);
                ctx.lineTo(boss.width/3, boss.height/2);
                ctx.lineTo(boss.width/2, boss.height/3);
                ctx.closePath();
                ctx.fill();
                
                // Boss details
                ctx.fillStyle = '#ff6699';
                ctx.fillRect(-boss.width/4, -10, boss.width/2, 20);
                
                // Boss eyes/lights
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(-boss.width/4, -boss.height/4, 8, 0, Math.PI * 2);
                ctx.arc(boss.width/4, -boss.height/4, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.restore();
                
                // Boss health bar
                const healthPercentage = boss.health / boss.maxHealth;
                const barWidth = boss.width + 20;
                ctx.fillStyle = '#333';
                ctx.fillRect(boss.x - barWidth/2, boss.y - boss.height/2 - 25, barWidth, 8);
                
                const healthColor = healthPercentage > 0.6 ? '#ff0000' : 
                                   healthPercentage > 0.3 ? '#ff6600' : '#990000';
                ctx.fillStyle = healthColor;
                ctx.fillRect(boss.x - barWidth/2, boss.y - boss.height/2 - 25, barWidth * healthPercentage, 8);
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(boss.x - barWidth/2, boss.y - boss.height/2 - 25, barWidth, 8);
                
                // Boss name and health text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(boss.name, boss.x, boss.y - boss.height/2 - 35);
                ctx.fillText(boss.name, boss.x, boss.y - boss.height/2 - 35);
                
                ctx.font = '12px Arial';
                ctx.fillText(`${boss.health}/${boss.maxHealth}`, boss.x, boss.y - boss.height/2 - 10);
            });
        }

        function checkLevelUp() {
            const newLevel = Math.floor(score / 2000) + 1;
            if (newLevel > level) {
                level = newLevel;
                enemySpeed += 0.3;
                enemySpawnRate = Math.min(0.05, enemySpawnRate + 0.004);
                
                showMessage(`Level ${level} - Malaysia Stronger!`, 2500);
                score += level * 100;
                
                if (level % 5 === 0) {
                    landmarks.forEach(landmark => {
                        landmark.health = landmark.maxHealth;
                    });
                }
            }
        }

        function gameLoop() {
            if (gameState !== 'playing') return;

            ctx.save();
            applyScreenShake();
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update
            updateStars();
            updatePlayer();
            updateBullets();
            updatePowerUps();
            updateCombo();
            spawnEnemy();
            updateEnemies();
            updateBosses();
            updateParticles();
            updateStateMessage();
            checkCollisions();
            checkLevelUp();
            checkWaveCompletion();
            updateUI();

            // Draw
            drawEnhancedBackground();
            drawEnhancedLandmarks();
            drawEnhancedPlayer();
            drawBullets();
            drawEnemies();
            drawBosses();
            drawPowerUps();
            drawParticles();
            drawStateMessage();

            ctx.restore();

            // Save high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('malaysiaDef_highScore', highScore);
            }

            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = 'playing';
            document.getElementById('startScreen').style.display = 'none';
            initGame();
            gameLoop();
        }

        function pauseGame() {
            if (gameState === 'playing') {
                gameState = 'paused';
                document.getElementById('pauseScreen').style.display = 'block';
            }
        }

        function resumeGame() {
            if (gameState === 'paused') {
                gameState = 'playing';
                document.getElementById('pauseScreen').style.display = 'none';
                gameLoop();
            }
        }

        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('finalScore').textContent = score.toLocaleString();
            document.getElementById('highestCombo').textContent = maxCombo;
            document.getElementById('gameOverScreen').style.display = 'block';
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('pauseScreen').style.display = 'none';
            startGame();
        }

        // Enhanced event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') {
                if (gameState === 'playing') {
                    pauseGame();
                } else if (gameState === 'paused') {
                    resumeGame();
                }
            }
            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Initialize
        document.getElementById('highScoreValue').textContent = parseInt(highScore).toLocaleString();
        initGame();
    </script>
</body>
</html>
