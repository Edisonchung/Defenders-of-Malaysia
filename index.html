<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Defenders of Malaysia">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Defenders of Malaysia - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available; /* iOS fix */
            font-family: 'Arial', sans-serif;
            color: white;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            /* iOS safe area support */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        .game-container {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 15px;
            box-shadow: 0 0 30px #00ffff88, inset 0 0 30px #00ffff22;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 600px;
            /* iOS-specific fixes */
            -webkit-overflow-scrolling: touch;
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
        }

        /* iOS device specific styles */
        @media (max-width: 768px) {
            .game-container {
                border-radius: 0;
                border: none;
                max-width: 100vw;
                max-height: 100vh;
                width: 100vw;
                height: 100vh;
                /* iOS viewport height fix */
                height: -webkit-fill-available;
            }
        }

        /* iPhone specific landscape adjustments */
        @media screen and (max-width: 896px) and (orientation: landscape) {
            .game-container {
                height: 100vh;
                height: -webkit-fill-available;
            }
        }

        /* iPad specific adjustments */
        @media screen and (min-width: 768px) and (max-width: 1024px) {
            .game-container {
                max-width: 90vw;
                max-height: 90vh;
            }
        }

        canvas {
            display: block;
            border-radius: 12px;
            background: radial-gradient(ellipse at center, #001122 0%, #000811 100%);
            width: 100%;
            height: 100%;
            /* iOS optimizations */
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        @media (max-width: 768px) {
            canvas {
                border-radius: 0;
            }
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
            flex-wrap: wrap;
        }

        .ui-left, .ui-right {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .score, .lives, .level, .weapon, .shield {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ffff;
            backdrop-filter: blur(5px);
            margin: 2px;
        }

        .weapon {
            background: rgba(255, 215, 0, 0.2);
            border-color: #FFD700;
            color: #FFD700;
        }

        .shield {
            background: rgba(0, 255, 0, 0.2);
            border-color: #00ff00;
            color: #00ff00;
        }

        @media (max-width: 480px) {
            .score, .lives, .level, .weapon, .shield {
                padding: 4px 8px;
                font-size: 12px;
            }
        }

        .start-screen, .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px 20px;
            box-shadow: 0 0 50px #00ffff88;
            backdrop-filter: blur(10px);
            max-width: 90%;
            width: 400px;
        }

        .start-screen h2, .game-over h2 {
            font-size: 36px;
            margin-bottom: 15px;
            text-shadow: 0 0 20px #00ffff;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 2s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }

        .start-btn, .restart-btn {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            border-radius: 25px;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
            touch-action: manipulation;
        }

        .start-btn:hover, .restart-btn:hover,
        .start-btn:active, .restart-btn:active {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.6);
        }

        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 150px;
            pointer-events: auto;
            z-index: 20;
            display: none;
        }

        @media (max-width: 768px), (max-height: 500px) {
            .mobile-controls {
                display: block;
            }
        }

        .joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            touch-action: none;
            /* iOS optimizations */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            /* Prevent iOS scroll bounce */
            overscroll-behavior: contain;
        }

        /* iPad larger joystick */
        @media (min-width: 768px) and (max-width: 1024px) {
            .joystick-area {
                width: 120px;
                height: 120px;
                bottom: 30px;
                left: 30px;
            }
        }

        .joystick-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #00ffff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            /* iOS touch improvements */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        /* iPad larger knob */
        @media (min-width: 768px) and (max-width: 1024px) {
            .joystick-knob {
                width: 50px;
                height: 50px;
            }
        }

        .fire-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 0, 0.2);
            border: 3px solid rgba(255, 255, 0, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ffff00;
            font-weight: bold;
            touch-action: manipulation;
            user-select: none;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.3);
        }

        .special-button {
            position: absolute;
            bottom: 110px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: rgba(255, 0, 255, 0.2);
            border: 3px solid rgba(255, 0, 255, 0.6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #ff00ff;
            font-weight: bold;
            touch-action: manipulation;
            user-select: none;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
        }

        .pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: white;
            cursor: pointer;
            pointer-events: auto;
            z-index: 30;
            touch-action: manipulation;
        }

        .achievement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.9);
            color: black;
            padding: 20px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 18px;
            text-align: center;
            box-shadow: 0 0 30px #FFD700;
            animation: achievementPop 3s ease-out forwards;
            z-index: 100;
            display: none;
        }

        @keyframes achievementPop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            90% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        .minimap {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 120px;
            height: 90px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 5px;
            pointer-events: none;
        }

        /* Orientation message - iOS specific */
        .orientation-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            text-align: center;
            padding: 20px;
            /* iOS safe area */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        /* Show orientation message on iPhone in portrait */
        @media screen and (orientation: portrait) and (max-width: 896px) {
            .orientation-message {
                display: flex;
            }
            .game-container {
                display: none;
            }
        }

        /* Don't show on iPad - it can play in portrait */
        @media screen and (orientation: portrait) and (min-width: 768px) and (max-width: 1024px) {
            .orientation-message {
                display: none;
            }
            .game-container {
                display: block;
            }
        }

        .combo-indicator {
            position: absolute;
            top: 120px;
            right: 15px;
            background: rgba(255, 215, 0, 0.8);
            color: black;
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
            display: none;
        }

        .weapon-upgrade-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 255, 0.9);
            color: black;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 0 30px #00ffff;
            animation: weaponUpgradePop 2s ease-out forwards;
            z-index: 99;
            display: none;
        }

        @keyframes weaponUpgradePop {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            90% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="orientation-message">
        <h3>üá≤üáæ Defenders of Malaysia üá≤üáæ</h3>
        <div style="font-size: 48px; margin: 20px 0; animation: rotate 2s infinite linear;">üì±</div>
        <p>Please rotate your device to landscape mode for the best gaming experience!</p>
        <p style="margin-top: 15px; font-size: 14px;">Sila putar peranti anda ke mod landskap untuk pengalaman permainan terbaik!</p>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="minimap" id="minimap"></div>
        
        <div class="ui-overlay">
            <div class="ui-left">
                <div class="score">Score: <span id="scoreValue">0</span></div>
                <div class="level">Level: <span id="levelValue">1</span></div>
                <div class="weapon">Weapon: <span id="weaponValue">Basic</span></div>
            </div>
            <div class="ui-right">
                <div class="lives">Lives: <span id="livesValue">3</span></div>
                <div class="level">Wave: <span id="waveValue">1</span></div>
                <div class="shield">Shield: <span id="shieldValue">100%</span></div>
            </div>
        </div>

        <div class="combo-indicator" id="comboIndicator">
            COMBO x<span id="comboValue">0</span>
        </div>

        <button class="pause-btn" onclick="togglePause()">‚è∏</button>
        <button class="settings-btn" onclick="toggleSettings()">‚öôÔ∏è</button>

        <div id="startScreen" class="start-screen">
            <h2>DEFENDERS OF MALAYSIA</h2>
            <p>üá≤üáæ Enhanced Edition - Protect the homeland! üá≤üáæ</p>
            <p>New Features: Power-ups, Shield System, Combo Multipliers!</p>
            <p class="desktop-controls" style="display: block;">WASD/Arrows: Move | SPACE: Shoot | X: Special Attack</p>
            <p class="mobile-controls-text" style="display: none;">Joystick: Move | Fire: Shoot | Special: Super Attack</p>
            <button class="start-btn" onclick="startGame()">MULA MISI!</button>
        </div>

        <div id="gameOverScreen" class="game-over" style="display: none;">
            <h2>MALAYSIA TERANCAM!</h2>
            <p>The Twin Towers have fallen...</p>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Highest Combo: <span id="finalCombo">0</span></p>
            <button class="restart-btn" onclick="restartGame()">CUBA LAGI!</button>
        </div>

        <div class="settings-panel" id="settingsPanel">
            <h3>‚öôÔ∏è GAME SETTINGS</h3>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">Left-Handed Mode</div>
                    <div class="setting-description">Swap controls for left-handed players</div>
                </div>
                <div class="toggle-switch" id="leftHandedToggle" onclick="toggleLeftHanded()">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">Show Minimap</div>
                    <div class="setting-description">Display tactical minimap</div>
                </div>
                <div class="toggle-switch active" id="minimapToggle" onclick="toggleMinimap()">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">Enhanced Graphics</div>
                    <div class="setting-description">Better effects but may reduce performance</div>
                </div>
                <div class="toggle-switch active" id="graphicsToggle" onclick="toggleGraphics()">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            
            <div class="setting-item">
                <div>
                    <div class="setting-label">Vibration</div>
                    <div class="setting-description">Haptic feedback on mobile devices</div>
                </div>
                <div class="toggle-switch active" id="vibrationToggle" onclick="toggleVibration()">
                    <div class="toggle-knob"></div>
                </div>
            </div>
            
            <div class="settings-buttons">
                <button class="settings-btn-action" onclick="applySettings()">APPLY</button>
                <button class="settings-btn-secondary" onclick="resetSettings()">RESET</button>
                <button class="settings-btn-secondary" onclick="closeSettings()">CLOSE</button>
            </div>
        </div>

        <div class="achievement" id="achievement"></div>
        <div class="weapon-upgrade-popup" id="weaponUpgrade"></div>

        <div class="mobile-controls">
            <div class="joystick-area" id="joystick">
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>
            <div class="fire-button" id="fireButton">üî•</div>
            <div class="special-button" id="specialButton">‚ö°</div>
        </div>

        <div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); text-align: center; font-size: 12px; color: #888; pointer-events: none;">
            <p>üá≤üáæ Mempertahankan Malaysia dengan teknologi canggih! üá≤üáæ</p>
        </div>
    </div>

    <script>
        // Enhanced mobile detection for iOS devices
        const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isAndroid = /Android/.test(navigator.userAgent);
        const isMobile = isiOS || isAndroid || 
                         /webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         (window.innerWidth <= 768) || 
                         ('ontouchstart' in window && window.innerHeight < window.innerWidth);
        
        // iOS specific detection
        const isiPad = isiOS && window.innerWidth >= 768;
        const isiPhone = isiOS && window.innerWidth < 768;
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');

        let gameScale = 1;

        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const rect = container.getBoundingClientRect();
            canvas.width = Math.floor(rect.width);
            canvas.height = Math.floor(rect.height);
            
            if (isMobile) {
                gameScale = Math.min(canvas.width / 800, canvas.height / 600);
            } else {
                gameScale = 1;
            }
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Enhanced game state
        let gameState = 'start';
        let score = 0;
        let lives = 3;
        let level = 1;
        let wave = 1;
        let shield = 100;
        let maxShield = 100;
        let weaponType = 'basic';
        let weaponLevel = 1;
        let specialCooldown = 0;
        let combo = 0;
        let maxCombo = 0;
        let comboTimer = 0;
        let achievements = new Set();

        // Game objects
        let player = {};
        let bullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];
        let landmarks = [];
        let bosses = [];
        let powerUps = [];
        let backgroundObjects = [];

        // Input handling
        const keys = {};
        let lastShotTime = 0;
        const shotCooldown = 120;

        // Mobile controls
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickMovement = { x: 0, y: 0 };
        let fireButtonPressed = false;
        let specialButtonPressed = false;
        
        // Game settings
        let gameSettings = {
            leftHanded: false,
            showMinimap: true,
            enhancedGraphics: true,
            vibrationEnabled: true
        };

        // Game timing
        let lastTime = 0;
        let animationId = null;

        // Load settings from localStorage if available
        function loadSettings() {
            try {
                const saved = localStorage.getItem('malaysiDefendersSettings');
                if (saved) {
                    gameSettings = { ...gameSettings, ...JSON.parse(saved) };
                    updateSettingsUI();
                    applySettings();
                }
            } catch (error) {
                console.log('Could not load settings:', error);
            }
        }

        // Save settings to localStorage
        function saveSettings() {
            try {
                localStorage.setItem('malaysiDefendersSettings', JSON.stringify(gameSettings));
            } catch (error) {
                console.log('Could not save settings:', error);
            }
        }

        // Enhanced weapon system
        const weaponTypes = {
            basic: { damage: 10, speed: 8, color: '#ffff00', sound: 'pew' },
            dual: { damage: 12, speed: 8, color: '#ff8800', sound: 'pew' },
            spread: { damage: 8, speed: 7, color: '#00ff88', sound: 'whoosh' },
            laser: { damage: 25, speed: 12, color: '#ff0088', sound: 'zap' },
            plasma: { damage: 35, speed: 10, color: '#8800ff', sound: 'boom' }
        };

        // Achievement system
        const achievementList = {
            firstKill: { name: "First Blood", desc: "Destroy your first enemy" },
            combo10: { name: "Combo Master", desc: "Achieve 10x combo" },
            wave5: { name: "Defender", desc: "Survive 5 waves" },
            boss1: { name: "Boss Slayer", desc: "Defeat your first boss" },
            score5000: { name: "High Scorer", desc: "Score 5000 points" },
            perfectWave: { name: "Flawless", desc: "Complete a wave without taking damage" },
            powerUp5: { name: "Power Collector", desc: "Collect 5 power-ups" }
        };

        function initGame() {
            player = {
                x: canvas.width / 2,
                y: canvas.height - 80 * gameScale,
                width: 40 * gameScale,
                height: 40 * gameScale,
                speed: 6 * gameScale,
                color: '#00ffff',
                invulnerable: 0
            };

            // Clear all arrays
            bullets = [];
            enemies = [];
            particles = [];
            stars = [];
            landmarks = [];
            bosses = [];
            powerUps = [];
            backgroundObjects = [];

            // Enhanced starfield with different star types
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: (Math.random() * 3 + 1) * gameScale,
                    speed: (Math.random() * 1 + 0.3) * gameScale,
                    twinkle: Math.random() * 100,
                    color: Math.random() > 0.8 ? '#ffcccc' : '#ffffff'
                });
            }

            // Enhanced Malaysian landmarks
            landmarks = [
                { 
                    name: 'Twin Towers', 
                    x: 150 * gameScale, 
                    y: canvas.height - 200 * gameScale, 
                    width: 40 * gameScale, 
                    height: 180 * gameScale, 
                    color: '#C0C0C0', 
                    health: 150, 
                    maxHealth: 150,
                    destroyed: false
                },
                { 
                    name: 'KL Tower', 
                    x: 350 * gameScale, 
                    y: canvas.height - 150 * gameScale, 
                    width: 20 * gameScale, 
                    height: 130 * gameScale, 
                    color: '#DAA520', 
                    health: 120, 
                    maxHealth: 120,
                    destroyed: false
                },
                { 
                    name: 'Sultan Abdul Samad', 
                    x: 550 * gameScale, 
                    y: canvas.height - 100 * gameScale, 
                    width: 80 * gameScale, 
                    height: 80 * gameScale, 
                    color: '#8B4513', 
                    health: 100, 
                    maxHealth: 100,
                    destroyed: false
                },
                { 
                    name: 'KLCC', 
                    x: 700 * gameScale, 
                    y: canvas.height - 120 * gameScale, 
                    width: 60 * gameScale, 
                    height: 100 * gameScale, 
                    color: '#4169E1', 
                    health: 130, 
                    maxHealth: 130,
                    destroyed: false
                }
            ];

            // Reset stats
            score = 0;
            lives = 3;
            level = 1;
            wave = 1;
            shield = 100;
            weaponType = 'basic';
            weaponLevel = 1;
            specialCooldown = 0;
            combo = 0;
            maxCombo = 0;
            comboTimer = 0;

            updateUI();
            showMessage("üá≤üáæ Malaysia's Defense Initiative Activated! üá≤üáæ", 3000);
        }

        function drawPlayer() {
            ctx.save();
            
            // Invulnerability effect
            if (player.invulnerable > 0) {
                ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.02);
                player.invulnerable--;
            }
            
            ctx.translate(player.x, player.y);
            ctx.scale(gameScale, gameScale);
            
            // Enhanced Malaysian fighter jet
            ctx.fillStyle = '#CC0000';
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(-18, 25);
            ctx.lineTo(-8, 20);
            ctx.lineTo(0, 15);
            ctx.lineTo(8, 20);
            ctx.lineTo(18, 25);
            ctx.closePath();
            ctx.fill();

            // Blue stripe
            ctx.fillStyle = '#003893';
            ctx.fillRect(-15, -5, 30, 8);

            // Gold details
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-5, -10, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(5, -10, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Engine glow with animation
            const glowIntensity = 0.8 + 0.2 * Math.sin(Date.now() * 0.01);
            ctx.fillStyle = `rgba(255, 68, 68, ${glowIntensity})`;
            ctx.beginPath();
            ctx.ellipse(0, 22, 10, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Weapon indicators
            if (weaponType !== 'basic') {
                ctx.fillStyle = weaponTypes[weaponType].color;
                ctx.fillRect(-20, 0, 4, 2);
                ctx.fillRect(16, 0, 4, 2);
            }

            // Shield effect
            if (shield > 0) {
                ctx.strokeStyle = `rgba(0, 255, 255, ${shield / maxShield * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function updatePlayer() {
            let moveX = 0;
            let moveY = 0;

            // Desktop controls
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) moveX -= 1;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) moveX += 1;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) moveY -= 1;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) moveY += 1;

            // Mobile controls
            const shouldUseMobile = isMobile || window.innerWidth <= 768;
            if (shouldUseMobile && (Math.abs(joystickMovement.x) > 0.1 || Math.abs(joystickMovement.y) > 0.1)) {
                moveX = joystickMovement.x;
                moveY = joystickMovement.y;
            }

            // Apply movement
            player.x += moveX * player.speed;
            player.y += moveY * player.speed;

            // Keep player in bounds
            player.x = Math.max(25 * gameScale, Math.min(canvas.width - 25 * gameScale, player.x));
            player.y = Math.max(25 * gameScale, Math.min(canvas.height - 25 * gameScale, player.y));

            // Shooting
            const shouldShoot = keys[' '] || (shouldUseMobile && fireButtonPressed);
            if (shouldShoot && Date.now() - lastShotTime > shotCooldown) {
                shoot();
                lastShotTime = Date.now();
            }

            // Special attack
            const shouldSpecial = keys['x'] || keys['X'] || (shouldUseMobile && specialButtonPressed);
            if (shouldSpecial && specialCooldown <= 0) {
                specialAttack();
                specialCooldown = 300; // 5 second cooldown
                specialButtonPressed = false;
            }

            if (specialCooldown > 0) specialCooldown--;
        }

        function shoot() {
            const weapon = weaponTypes[weaponType];
            
            switch(weaponType) {
                case 'basic':
                    bullets.push(createBullet(player.x, player.y - 15 * gameScale, 0, weapon));
                    break;
                case 'dual':
                    bullets.push(createBullet(player.x - 10 * gameScale, player.y - 10 * gameScale, 0, weapon));
                    bullets.push(createBullet(player.x + 10 * gameScale, player.y - 10 * gameScale, 0, weapon));
                    break;
                case 'spread':
                    for (let i = -1; i <= 1; i++) {
                        bullets.push(createBullet(player.x, player.y - 15 * gameScale, i * 0.3, weapon));
                    }
                    break;
                case 'laser':
                    bullets.push(createBullet(player.x, player.y - 20 * gameScale, 0, weapon, 'laser'));
                    break;
                case 'plasma':
                    bullets.push(createBullet(player.x, player.y - 20 * gameScale, 0, weapon, 'plasma'));
                    break;
            }
        }

        function createBullet(x, y, angle, weapon, type = 'normal') {
            return {
                x: x,
                y: y,
                width: type === 'laser' ? 6 * gameScale : 4 * gameScale,
                height: type === 'laser' ? 20 * gameScale : type === 'plasma' ? 8 * gameScale : 12 * gameScale,
                speed: weapon.speed * gameScale,
                angle: angle,
                color: weapon.color,
                damage: weapon.damage,
                type: type,
                trail: []
            };
        }

        function specialAttack() {
            // Screen-clearing special attack
            createExplosion(player.x, player.y, '#FFD700', 50);
            
            // Damage all enemies on screen
            enemies.forEach(enemy => {
                enemy.health = (enemy.health || 100) - 50;
                createExplosion(enemy.x, enemy.y, '#FFD700');
            });
            
            // Remove weak enemies
            enemies = enemies.filter(enemy => (enemy.health || 100) > 0);
            
            // Add score for special
            score += enemies.length * 10;
            
            showMessage("üåü SPECIAL ATTACK ACTIVATED! üåü", 1500);
            
            // Vibration based on settings
            if (gameSettings.vibrationEnabled && (isMobile || isiOS) && navigator.vibrate) {
                navigator.vibrate([100, 50, 100, 50, 200]);
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Add to trail for laser effects
                if (bullet.type === 'laser' || bullet.type === 'plasma') {
                    bullet.trail.push({ x: bullet.x, y: bullet.y });
                    if (bullet.trail.length > 5) bullet.trail.shift();
                }
                
                bullet.y -= bullet.speed;
                bullet.x += bullet.angle * bullet.speed * 0.5;

                if (bullet.y < 0 || bullet.x < 0 || bullet.x > canvas.width) {
                    bullets.splice(i, 1);
                }
            }
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.save();
                
                // Draw trail for special bullets
                if (bullet.trail && bullet.trail.length > 1) {
                    ctx.strokeStyle = bullet.color;
                    ctx.lineWidth = bullet.width;
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath();
                    ctx.moveTo(bullet.trail[0].x, bullet.trail[0].y);
                    for (let i = 1; i < bullet.trail.length; i++) {
                        ctx.lineTo(bullet.trail[i].x, bullet.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                ctx.fillStyle = bullet.color;
                ctx.shadowColor = bullet.color;
                ctx.shadowBlur = bullet.type === 'laser' ? 15 * gameScale : bullet.type === 'plasma' ? 20 * gameScale : 8 * gameScale;
                
                if (bullet.type === 'plasma') {
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.height / 2, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        // Enhanced power-up system
        function spawnPowerUp() {
            if (Math.random() < 0.003) {
                const types = ['weapon', 'shield', 'life', 'points', 'special'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                powerUps.push({
                    x: Math.random() * (canvas.width - 40 * gameScale) + 20 * gameScale,
                    y: -20 * gameScale,
                    width: 25 * gameScale,
                    height: 25 * gameScale,
                    type: type,
                    speed: 2 * gameScale,
                    color: getPowerUpColor(type),
                    pulseTimer: 0
                });
            }
        }

        function getPowerUpColor(type) {
            switch(type) {
                case 'weapon': return '#FFD700';
                case 'shield': return '#00ff00';
                case 'life': return '#ff0066';
                case 'points': return '#00ffff';
                case 'special': return '#ff00ff';
                default: return '#ffffff';
            }
        }

        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;
                powerUp.pulseTimer += 0.1;

                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                    continue;
                }

                // Check collision with player
                const dist = Math.sqrt((player.x - powerUp.x) ** 2 + (player.y - powerUp.y) ** 2);
                if (dist < 30 * gameScale) {
                    collectPowerUp(powerUp);
                    powerUps.splice(i, 1);
                }
            }
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                ctx.save();
                ctx.translate(powerUp.x, powerUp.y);
                
                const pulse = 0.8 + 0.2 * Math.sin(powerUp.pulseTimer * 5);
                ctx.scale(pulse, pulse);
                
                ctx.fillStyle = powerUp.color;
                ctx.shadowColor = powerUp.color;
                ctx.shadowBlur = 15 * gameScale;
                
                // Draw different shapes for different power-ups
                switch(powerUp.type) {
                    case 'weapon':
                        ctx.fillRect(-10 * gameScale, -10 * gameScale, 20 * gameScale, 20 * gameScale);
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * gameScale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText('W', 0, 4 * gameScale);
                        break;
                    case 'shield':
                        ctx.beginPath();
                        ctx.arc(0, 0, 12 * gameScale, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * gameScale}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText('S', 0, 4 * gameScale);
                        break;
                    case 'life':
                        // Heart shape
                        ctx.beginPath();
                        ctx.moveTo(0, 5 * gameScale);
                        ctx.bezierCurveTo(-10 * gameScale, -5 * gameScale, -15 * gameScale, 0, 0, 15 * gameScale);
                        ctx.bezierCurveTo(15 * gameScale, 0, 10 * gameScale, -5 * gameScale, 0, 5 * gameScale);
                        ctx.fill();
                        break;
                    case 'points':
                        // Star shape
                        ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 144 - 90) * Math.PI / 180;
                            const x = Math.cos(angle) * 12 * gameScale;
                            const y = Math.sin(angle) * 12 * gameScale;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.fill();
                        break;
                    case 'special':
                        // Lightning bolt
                        ctx.beginPath();
                        ctx.moveTo(-5 * gameScale, -10 * gameScale);
                        ctx.lineTo(5 * gameScale, -2 * gameScale);
                        ctx.lineTo(0, 0);
                        ctx.lineTo(8 * gameScale, 10 * gameScale);
                        ctx.lineTo(-2 * gameScale, 2 * gameScale);
                        ctx.lineTo(2 * gameScale, 0);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        function collectPowerUp(powerUp) {
            switch(powerUp.type) {
                case 'weapon':
                    upgradeWeapon();
                    break;
                case 'shield':
                    shield = Math.min(maxShield, shield + 25);
                    showMessage("üõ°Ô∏è Shield Restored! üõ°Ô∏è", 1000);
                    break;
                case 'life':
                    lives++;
                    showMessage("‚ù§Ô∏è Extra Life! ‚ù§Ô∏è", 1000);
                    break;
                case 'points':
                    score += 500;
                    showMessage("‚ú® Bonus Points! ‚ú®", 1000);
                    break;
                case 'special':
                    specialCooldown = Math.max(0, specialCooldown - 180);
                    showMessage("‚ö° Special Recharged! ‚ö°", 1000);
                    break;
            }
            
            createExplosion(powerUp.x, powerUp.y, powerUp.color);
            
            // Vibration based on settings
            if (gameSettings.vibrationEnabled && (isMobile || isiOS) && navigator.vibrate) {
                navigator.vibrate(100);
            }
            
            checkAchievement('powerUp5');
        }

        function upgradeWeapon() {
            const weapons = ['basic', 'dual', 'spread', 'laser', 'plasma'];
            const currentIndex = weapons.indexOf(weaponType);
            
            if (currentIndex < weapons.length - 1) {
                weaponType = weapons[currentIndex + 1];
                weaponLevel++;
                
                const popup = document.getElementById('weaponUpgrade');
                popup.innerHTML = `üî´ WEAPON UPGRADED!<br>${weaponType.toUpperCase()}`;
                popup.style.display = 'block';
                
                setTimeout(() => {
                    popup.style.display = 'none';
                }, 2000);
                
                showMessage(`üî´ Weapon Upgraded: ${weaponType.toUpperCase()}! üî´`, 2000);
            } else {
                // Max weapon, give points instead
                score += 1000;
                showMessage("üî´ MAX WEAPON - Bonus Points! üî´", 1000);
            }
        }

        // Enhanced combo system
        function increaseCombo() {
            combo++;
            comboTimer = 180; // 3 seconds
            maxCombo = Math.max(maxCombo, combo);
            
            if (combo >= 5) {
                document.getElementById('comboIndicator').style.display = 'block';
                document.getElementById('comboValue').textContent = combo;
            }
            
            // Combo bonuses
            if (combo === 10) checkAchievement('combo10');
            if (combo % 10 === 0) {
                score += combo * 5;
                showMessage(`üî• ${combo}x COMBO BONUS! üî•`, 1500);
            }
        }

        function updateCombo() {
            if (comboTimer > 0) {
                comboTimer--;
            } else if (combo > 0) {
                combo = 0;
                document.getElementById('comboIndicator').style.display = 'none';
            }
        }

        // Enhanced enemy system with health
        function spawnEnemy() {
            if (Math.random() < 0.025) {
                const types = ['basic', 'fast', 'heavy', 'zigzag', 'bomber'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                let enemy = {
                    x: Math.random() * (canvas.width - 40 * gameScale) + 20 * gameScale,
                    y: -30 * gameScale,
                    type: type,
                    zigzagDirection: 1,
                    zigzagTimer: 0,
                    shootTimer: 0
                };

                switch(type) {
                    case 'basic':
                        enemy.width = 30 * gameScale;
                        enemy.height = 30 * gameScale;
                        enemy.speed = 2 * gameScale;
                        enemy.color = '#ff4444';
                        enemy.points = 20;
                        enemy.health = 10;
                        break;
                    case 'fast':
                        enemy.width = 25 * gameScale;
                        enemy.height = 25 * gameScale;
                        enemy.speed = 4 * gameScale;
                        enemy.color = '#ff8844';
                        enemy.points = 30;
                        enemy.health = 5;
                        break;
                    case 'heavy':
                        enemy.width = 45 * gameScale;
                        enemy.height = 45 * gameScale;
                        enemy.speed = 1.5 * gameScale;
                        enemy.color = '#8844ff';
                        enemy.points = 50;
                        enemy.health = 25;
                        break;
                    case 'zigzag':
                        enemy.width = 30 * gameScale;
                        enemy.height = 30 * gameScale;
                        enemy.speed = 2.5 * gameScale;
                        enemy.color = '#44ff88';
                        enemy.points = 35;
                        enemy.health = 15;
                        break;
                    case 'bomber':
                        enemy.width = 35 * gameScale;
                        enemy.height = 35 * gameScale;
                        enemy.speed = 1.8 * gameScale;
                        enemy.color = '#ff4488';
                        enemy.points = 40;
                        enemy.health = 20;
                        break;
                }

                enemies.push(enemy);
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Movement patterns
                switch(enemy.type) {
                    case 'zigzag':
                        enemy.zigzagTimer++;
                        if (enemy.zigzagTimer > 30) {
                            enemy.zigzagDirection *= -1;
                            enemy.zigzagTimer = 0;
                        }
                        enemy.x += enemy.zigzagDirection * 3 * gameScale;
                        break;
                    case 'bomber':
                        enemy.shootTimer++;
                        if (enemy.shootTimer > 120 && enemy.y > 100 * gameScale) {
                            // Bomber shoots
                            enemies.push({
                                x: enemy.x,
                                y: enemy.y + 20 * gameScale,
                                width: 8 * gameScale,
                                height: 8 * gameScale,
                                speed: 3 * gameScale,
                                color: '#ff6666',
                                points: 5,
                                health: 1,
                                type: 'enemy_bullet'
                            });
                            enemy.shootTimer = 0;
                        }
                        break;
                }
                
                enemy.y += enemy.speed;

                // Remove if off screen
                if (enemy.y > canvas.height) {
                    enemies.splice(i, 1);
                    
                    if (enemy.type !== 'enemy_bullet') {
                        lives--;
                        shield = Math.max(0, shield - 20);
                        
                        // Damage random landmark
                        const activeLandmarks = landmarks.filter(l => !l.destroyed);
                        if (activeLandmarks.length > 0) {
                            const landmark = activeLandmarks[Math.floor(Math.random() * activeLandmarks.length)];
                            landmark.health = Math.max(0, landmark.health - 30);
                            if (landmark.health <= 0) {
                                landmark.destroyed = true;
                                createExplosion(landmark.x, landmark.y, '#ff4444', 30);
                                showMessage(`üí• ${landmark.name} DESTROYED! üí•`, 2000);
                            }
                            createExplosion(landmark.x, landmark.y, '#ff4444');
                        }
                        
                        combo = 0; // Reset combo on miss
                        
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(200);
                        }
                        
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                }
            }
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.scale(gameScale, gameScale);
                
                // Health bar for stronger enemies
                if (enemy.health > 10 && enemy.type !== 'enemy_bullet') {
                    const healthPercentage = enemy.health / getMaxEnemyHealth(enemy.type);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-15, -25, 30, 3);
                    ctx.fillStyle = healthPercentage > 0.5 ? '#00ff00' : healthPercentage > 0.2 ? '#ffff00' : '#ff0000';
                    ctx.fillRect(-15, -25, 30 * healthPercentage, 3);
                }
                
                ctx.fillStyle = enemy.color;
                ctx.shadowColor = enemy.color;
                ctx.shadowBlur = 8;
                
                // Enhanced enemy shapes
                ctx.beginPath();
                switch(enemy.type) {
                    case 'basic':
                        ctx.moveTo(0, -15);
                        ctx.lineTo(-12, 15);
                        ctx.lineTo(12, 15);
                        break;
                    case 'fast':
                        ctx.moveTo(0, -12);
                        ctx.lineTo(-10, 0);
                        ctx.lineTo(0, 12);
                        ctx.lineTo(10, 0);
                        break;
                    case 'heavy':
                        ctx.rect(-20, -15, 40, 30);
                        // Add extra details
                        ctx.fill();
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(-15, -10, 30, 5);
                        ctx.fillRect(-15, 5, 30, 5);
                        break;
                    case 'zigzag':
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 144 - 90) * Math.PI / 180;
                            const x = Math.cos(angle) * 12;
                            const y = Math.sin(angle) * 12;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        break;
                    case 'bomber':
                        ctx.rect(-17, -17, 34, 34);
                        ctx.fill();
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        break;
                    case 'enemy_bullet':
                        ctx.rect(-4, -4, 8, 8);
                        break;
                }
                
                if (enemy.type !== 'heavy' && enemy.type !== 'bomber') {
                    ctx.closePath();
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        function getMaxEnemyHealth(type) {
            switch(type) {
                case 'basic': return 10;
                case 'fast': return 5;
                case 'heavy': return 25;
                case 'zigzag': return 15;
                case 'bomber': return 20;
                default: return 1;
            }
        }

        // Enhanced collision detection
        function checkCollisions() {
            // Bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (bullet.x > enemy.x - enemy.width/2 &&
                        bullet.x < enemy.x + enemy.width/2 &&
                        bullet.y > enemy.y - enemy.height/2 &&
                        bullet.y < enemy.y + enemy.height/2) {
                        
                        enemy.health -= bullet.damage;
                        createExplosion(bullet.x, bullet.y, bullet.color);
                        bullets.splice(i, 1);
                        
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x, enemy.y, enemy.color);
                            score += enemy.points * (1 + Math.floor(combo / 5)); // Combo multiplier
                            enemies.splice(j, 1);
                            increaseCombo();
                            
                            checkAchievement('firstKill');
                            
                            if (isMobile && navigator.vibrate) {
                                navigator.vibrate(50);
                            }
                        }
                        break;
                    }
                }
            }

            // Player-enemy collisions
            if (player.invulnerable <= 0) {
                enemies.forEach((enemy, index) => {
                    const dist = Math.sqrt((player.x - enemy.x) ** 2 + (player.y - enemy.y) ** 2);
                    if (dist < (25 + enemy.width/2) * gameScale) {
                        createExplosion(enemy.x, enemy.y, enemy.color);
                        enemies.splice(index, 1);
                        
                        shield -= 25;
                        if (shield <= 0) {
                            shield = 0;
                            lives--;
                            shield = maxShield; // Reset shield on life loss
                            player.invulnerable = 120; // 2 seconds invulnerability
                        }
                        
                        combo = 0; // Reset combo on hit
                        
                        if (isMobile && navigator.vibrate) {
                            navigator.vibrate(300);
                        }
                        
                        if (lives <= 0) {
                            gameOver();
                        }
                    }
                });
            }
        }

        // Enhanced particle system
        function createExplosion(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10 * gameScale,
                    vy: (Math.random() - 0.5) * 10 * gameScale,
                    life: 40 + Math.random() * 20,
                    maxLife: 40 + Math.random() * 20,
                    color: color,
                    size: (Math.random() * 6 + 2) * gameScale,
                    gravity: 0.1 * gameScale
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity;
                p.vx *= 0.98;
                p.vy *= 0.98;
                p.life--;
                p.size *= 0.97;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 5 * gameScale;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        // Enhanced starfield
        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                star.twinkle += 2;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }

        function drawStars() {
            stars.forEach(star => {
                ctx.save();
                ctx.globalAlpha = 0.5 + 0.3 * Math.sin(star.twinkle * 0.05);
                ctx.fillStyle = star.color;
                ctx.shadowColor = star.color;
                ctx.shadowBlur = 2;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        // Enhanced landmarks with destruction effects
        function drawLandmarks() {
            landmarks.forEach(landmark => {
                if (landmark.destroyed) return;
                
                ctx.save();
                ctx.globalAlpha = 0.8;
                const healthPercentage = landmark.health / landmark.maxHealth;
                const baseColor = healthPercentage > 0.7 ? landmark.color : 
                                 healthPercentage > 0.3 ? '#888888' : '#444444';
                
                // Add damage effects
                if (healthPercentage < 0.5) {
                    ctx.globalAlpha = 0.6 + 0.2 * Math.sin(Date.now() * 0.01);
                }
                
                ctx.fillStyle = baseColor;
                
                // Enhanced landmark drawing with more details
                if (landmark.name === 'Twin Towers') {
                    // Twin towers with more detail
                    ctx.fillRect(landmark.x - 10 * gameScale, landmark.y, 20 * gameScale, landmark.height);
                    ctx.fillRect(landmark.x + 10 * gameScale, landmark.y, 20 * gameScale, landmark.height);
                    
                    // Sky bridge
                    ctx.fillRect(landmark.x - 10 * gameScale, landmark.y + 80 * gameScale, 40 * gameScale, 6 * gameScale);
                    
                    // Windows with lights
                    ctx.fillStyle = healthPercentage > 0.3 ? '#FFD700' : '#666';
                    for (let floor = 0; floor < 12; floor++) {
                        for (let window = 0; window < 2; window++) {
                            const windowX = landmark.x + (window === 0 ? -8 : 12) * gameScale;
                            const windowY = landmark.y + floor * 15 * gameScale;
                            if (Math.random() > 0.3) { // Some windows are lit
                                ctx.fillRect(windowX, windowY, 3 * gameScale, 3 * gameScale);
                            }
                        }
                    }
                    
                    // Spires
                    ctx.fillStyle = baseColor;
                    ctx.fillRect(landmark.x - 5 * gameScale, landmark.y - 20 * gameScale, 10 * gameScale, 20 * gameScale);
                    ctx.fillRect(landmark.x + 15 * gameScale, landmark.y - 20 * gameScale, 10 * gameScale, 20 * gameScale);
                }
                // ... (other landmark drawings remain similar but enhanced)
                
                // Enhanced health bar
                if (landmark.health < landmark.maxHealth) {
                    const barWidth = Math.max(landmark.width, 50 * gameScale);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(landmark.x - barWidth/2, landmark.y - 25 * gameScale, barWidth, 6 * gameScale);
                    
                    // Gradient health bar
                    const gradient = ctx.createLinearGradient(landmark.x - barWidth/2, 0, landmark.x + barWidth/2, 0);
                    gradient.addColorStop(0, healthPercentage > 0.7 ? '#00ff00' : '#ff0000');
                    gradient.addColorStop(1, healthPercentage > 0.7 ? '#88ff88' : '#ffaaaa');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(landmark.x - barWidth/2, landmark.y - 25 * gameScale, barWidth * healthPercentage, 6 * gameScale);
                    
                    // Health bar border
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(landmark.x - barWidth/2, landmark.y - 25 * gameScale, barWidth, 6 * gameScale);
                }
                
                ctx.restore();
            });
        }

        // Enhanced UI and achievement system
        function checkAchievement(achievementId) {
            if (achievements.has(achievementId)) return;
            
            let unlocked = false;
            
            switch(achievementId) {
                case 'firstKill':
                    unlocked = true;
                    break;
                case 'combo10':
                    unlocked = combo >= 10;
                    break;
                case 'wave5':
                    unlocked = wave >= 5;
                    break;
                case 'score5000':
                    unlocked = score >= 5000;
                    break;
                case 'powerUp5':
                    unlocked = achievements.size >= 4; // Simple check for demo
                    break;
            }
            
            if (unlocked) {
                achievements.add(achievementId);
                showAchievement(achievementList[achievementId]);
            }
        }

        function showAchievement(achievement) {
            const achievementEl = document.getElementById('achievement');
            achievementEl.innerHTML = `
                üèÜ ACHIEVEMENT UNLOCKED! üèÜ<br>
                <strong>${achievement.name}</strong><br>
                ${achievement.desc}
            `;
            achievementEl.style.display = 'block';
            
            setTimeout(() => {
                achievementEl.style.display = 'none';
            }, 3000);
            
            if (isMobile && navigator.vibrate) {
                navigator.vibrate([200, 100, 200]);
            }
        }

        function updateUI() {
            document.getElementById('scoreValue').textContent = score.toLocaleString();
            document.getElementById('livesValue').textContent = lives;
            document.getElementById('levelValue').textContent = level;
            document.getElementById('waveValue').textContent = wave;
            document.getElementById('weaponValue').textContent = weaponType.charAt(0).toUpperCase() + weaponType.slice(1);
            document.getElementById('shieldValue').textContent = Math.round((shield / maxShield) * 100) + '%';
        }

        // Enhanced message system
        let stateMessage = "";
        let stateMessageTimer = 0;

        function showMessage(message, duration = 2000) {
            stateMessage = message;
            stateMessageTimer = duration;
        }

        function updateStateMessage() {
            if (stateMessageTimer > 0) {
                stateMessageTimer -= 16;
            }
        }

        function drawStateMessage() {
            if (stateMessageTimer > 0) {
                ctx.save();
                const alpha = Math.min(1, stateMessageTimer / 500);
                ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                ctx.font = `bold ${Math.min(28, 20 * gameScale)}px Arial`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#003893';
                ctx.lineWidth = 3;
                ctx.strokeText(stateMessage, canvas.width / 2, canvas.height / 2 - 100 * gameScale);
                ctx.fillText(stateMessage, canvas.width / 2, canvas.height / 2 - 100 * gameScale);
                ctx.restore();
            }
        }

        // Enhanced minimap with safety checks and settings
        function drawMinimap() {
            if (!gameSettings.showMinimap) return;
            
            try {
                const minimapEl = document.getElementById('minimap');
                if (!minimapEl) return;
                
                const minimapCtx = minimapEl.getContext('2d');
                if (!minimapCtx) return;
                
                const scaleX = 120 / canvas.width;
                const scaleY = 90 / canvas.height;
                
                minimapCtx.clearRect(0, 0, 120, 90);
                
                // Background
                minimapCtx.fillStyle = 'rgba(0, 20, 40, 0.8)';
                minimapCtx.fillRect(0, 0, 120, 90);
                
                // Player
                if (player && player.x !== undefined && player.y !== undefined) {
                    minimapCtx.fillStyle = '#00ffff';
                    minimapCtx.fillRect(player.x * scaleX - 1, player.y * scaleY - 1, 2, 2);
                }
                
                // Enemies
                minimapCtx.fillStyle = '#ff4444';
                enemies.forEach(enemy => {
                    if (enemy && enemy.x !== undefined && enemy.y !== undefined) {
                        minimapCtx.fillRect(enemy.x * scaleX - 1, enemy.y * scaleY - 1, 2, 2);
                    }
                });
                
                // Power-ups
                minimapCtx.fillStyle = '#FFD700';
                powerUps.forEach(powerUp => {
                    if (powerUp && powerUp.x !== undefined && powerUp.y !== undefined) {
                        minimapCtx.fillRect(powerUp.x * scaleX - 1, powerUp.y * scaleY - 1, 2, 2);
                    }
                });
                
                // Landmarks
                landmarks.forEach(landmark => {
                    if (landmark && !landmark.destroyed && landmark.x !== undefined && landmark.y !== undefined) {
                        minimapCtx.fillStyle = landmark.health > landmark.maxHealth * 0.5 ? '#00ff00' : '#ff8800';
                        minimapCtx.fillRect(landmark.x * scaleX - 2, landmark.y * scaleY - 2, 4, 4);
                    }
                });
            } catch (error) {
                console.warn('Minimap draw error:', error);
            }
        }

        // Mobile controls initialization with iOS enhancements
        function initMobileControls() {
            // Enhanced mobile detection for controls
            const shouldUseMobile = isMobile || isiPad || window.innerWidth <= 1024;
            
            if (shouldUseMobile) {
                document.querySelectorAll('.desktop-controls').forEach(el => el.style.display = 'none');
                document.querySelectorAll('.mobile-controls-text').forEach(el => el.style.display = 'block');
                
                const mobileControlsDiv = document.querySelector('.mobile-controls');
                if (mobileControlsDiv) {
                    mobileControlsDiv.style.display = 'block';
                }
                
                const joystick = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystickKnob');
                const fireButton = document.getElementById('fireButton');
                const specialButton = document.getElementById('specialButton');

                // Enhanced joystick for iOS with better touch handling
                function handleJoystickStart(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    joystickActive = true;
                    
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter.x = rect.left + rect.width / 2;
                    joystickCenter.y = rect.top + rect.height / 2;
                    
                    // iOS haptic feedback
                    if (isiOS && window.navigator && window.navigator.vibrate) {
                        window.navigator.vibrate(50);
                    }
                    
                    // Prevent iOS scroll
                    document.body.style.overflow = 'hidden';
                }

                function handleJoystickMove(e) {
                    if (!joystickActive) return;
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const touch = e.touches ? e.touches[0] : e;
                    if (!touch) return;
                    
                    const deltaX = touch.clientX - joystickCenter.x;
                    const deltaY = touch.clientY - joystickCenter.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const maxDistance = isiPad ? 40 : 35;

                    if (distance <= maxDistance) {
                        joystickMovement.x = deltaX / maxDistance;
                        joystickMovement.y = deltaY / maxDistance;
                        joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                    } else {
                        const angle = Math.atan2(deltaY, deltaX);
                        const limitedX = Math.cos(angle) * maxDistance;
                        const limitedY = Math.sin(angle) * maxDistance;
                        joystickMovement.x = limitedX / maxDistance;
                        joystickMovement.y = limitedY / maxDistance;
                        joystickKnob.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
                    }
                }

                function handleJoystickEnd(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    joystickActive = false;
                    joystickMovement.x = 0;
                    joystickMovement.y = 0;
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                    
                    // Restore iOS scroll
                    document.body.style.overflow = '';
                }

                // iOS-optimized touch events
                if (joystick) {
                    joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
                    joystick.addEventListener('touchmove', handleJoystickMove, { passive: false });
                    joystick.addEventListener('touchend', handleJoystickEnd, { passive: false });
                    joystick.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
                }

                // Enhanced fire button for iOS
                function handleFireStart(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    fireButtonPressed = true;
                    fireButton.style.transform = 'scale(0.9)';
                    fireButton.style.background = 'rgba(255, 255, 0, 0.5)';
                    
                    if (isiOS && window.navigator && window.navigator.vibrate) {
                        window.navigator.vibrate(30);
                    }
                }

                function handleFireEnd(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    fireButtonPressed = false;
                    fireButton.style.transform = 'scale(1)';
                    fireButton.style.background = 'rgba(255, 255, 0, 0.2)';
                }

                if (fireButton) {
                    fireButton.addEventListener('touchstart', handleFireStart, { passive: false });
                    fireButton.addEventListener('touchend', handleFireEnd, { passive: false });
                    fireButton.addEventListener('touchcancel', handleFireEnd, { passive: false });
                }

                // Enhanced special button for iOS
                function handleSpecialStart(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (specialCooldown <= 0) {
                        specialButtonPressed = true;
                        specialButton.style.transform = 'scale(0.9)';
                        specialButton.style.background = 'rgba(255, 0, 255, 0.5)';
                        
                        if (isiOS && window.navigator && window.navigator.vibrate) {
                            window.navigator.vibrate(100);
                        }
                    }
                }

                function handleSpecialEnd(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    specialButtonPressed = false;
                    specialButton.style.transform = 'scale(1)';
                    specialButton.style.background = 'rgba(255, 0, 255, 0.2)';
                }

                if (specialButton) {
                    specialButton.addEventListener('touchstart', handleSpecialStart, { passive: false });
                    specialButton.addEventListener('touchend', handleSpecialEnd, { passive: false });
                    specialButton.addEventListener('touchcancel', handleSpecialEnd, { passive: false });
                }
                
                // Prevent iOS bounce scrolling
                document.addEventListener('touchmove', function(e) {
                    if (e.target.closest('.mobile-controls')) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
        }

        // Enhanced level progression
        function checkLevelUp() {
            const newLevel = Math.floor(score / 2000) + 1;
            if (newLevel > level) {
                level = newLevel;
                
                // Level rewards
                if (level % 3 === 0) {
                    // Weapon upgrade every 3 levels
                    upgradeWeapon();
                }
                
                if (level % 5 === 0) {
                    // Full heal landmarks every 5 levels
                    landmarks.forEach(landmark => {
                        if (!landmark.destroyed) {
                            landmark.health = landmark.maxHealth;
                        }
                    });
                    lives++;
                    showMessage(`üè• MEDICAL SUPPORT ARRIVED! +1 LIFE üè•`, 3000);
                }
                
                // Milestone messages
                const milestones = {
                    5: "üèõÔ∏è PUTRAJAYA FORTIFIED! üèõÔ∏è",
                    10: "üå¥ PENANG SECURED! üå¥", 
                    15: "ü¶Ö SABAH PROTECTED! ü¶Ö",
                    20: "üå∫ SARAWAK DEFENDED! üå∫",
                    25: "üëë ROYAL PALACE SAFE! üëë"
                };
                
                if (milestones[level]) {
                    showMessage(milestones[level], 4000);
                } else {
                    showMessage(`üí™ LEVEL ${level} - MALAYSIA STRONGER! üí™`, 2000);
                }
                
                createExplosion(canvas.width / 2, 100 * gameScale, '#FFD700', 25);
                score += level * 100;
                
                if (isMobile && navigator.vibrate) {
                    navigator.vibrate([150, 75, 150, 75, 150]);
                }
                
                checkAchievement('wave5');
                if (score >= 5000) checkAchievement('score5000');
            }
        }

        // Enhanced wave system
        function checkWaveCompletion() {
            if (enemies.length === 0 && Math.random() < 0.1) {
                wave++;
                
                // Wave completion effects
                const malaysianStates = [
                    'Johor Liberated!', 'Kedah Secured!', 'Kelantan Protected!',
                    'Melaka Defended!', 'Negeri Sembilan Safe!', 'Pahang Secured!',
                    'Perak Protected!', 'Perlis Defended!', 'Terengganu Safe!',
                    'Selangor Secured!', 'Federal Territory Protected!'
                ];
                
                const stateIndex = Math.min(wave - 1, malaysianStates.length - 1);
                showMessage(`üåä Wave ${wave}: ${malaysianStates[stateIndex]} üåä`, 3000);
                
                // Wave bonuses
                score += 100 + (wave * 25);
                shield = Math.min(maxShield, shield + 15);
                
                // Spawn power-up as wave reward
                if (wave % 3 === 0) {
                    powerUps.push({
                        x: canvas.width / 2,
                        y: -20 * gameScale,
                        width: 25 * gameScale,
                        height: 25 * gameScale,
                        type: 'weapon',
                        speed: 1 * gameScale,
                        color: '#FFD700',
                        pulseTimer: 0
                    });
                }
            }
        }

        // Enhanced game loop with proper timing
        function gameLoop(currentTime = 0) {
            if (gameState !== 'playing') {
                animationId = null;
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            try {
                // Update all systems
                updateStars();
                updatePlayer();
                updateBullets();
                spawnEnemy();
                spawnPowerUp();
                updateEnemies();
                updatePowerUps();
                updateParticles();
                updateStateMessage();
                updateCombo();
                checkCollisions();
                checkLevelUp();
                checkWaveCompletion();
                updateUI();

                // Draw everything
                drawStars();
                drawLandmarks();
                drawPlayer();
                drawBullets();
                drawEnemies();
                drawPowerUps();
                drawParticles();
                drawStateMessage();
                drawMinimap();
            } catch (error) {
                console.error('Game loop error:', error);
                // Continue anyway
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // Game control functions
        function startGame() {
            console.log('Starting game...');
            
            // Cancel any existing animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            // Set game state first
            gameState = 'playing';
            
            // Hide start screen
            const startScreen = document.getElementById('startScreen');
            if (startScreen) {
                startScreen.style.display = 'none';
            }
            
            // Initialize game
            try {
                initGame();
                console.log('Game initialized');
                
                // Initialize mobile controls
                initMobileControls();
                console.log('Mobile controls initialized');
                
                // Start game loop
                lastTime = performance.now();
                gameLoop();
                console.log('Game loop started');
                
            } catch (error) {
                console.error('Error starting game:', error);
                // Fallback - try again
                setTimeout(() => {
                    initGame();
                    initMobileControls();
                    gameLoop();
                }, 100);
            }
        }

        function gameOver() {
            console.log('Game over');
            gameState = 'gameOver';
            
            // Cancel animation loop
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            document.getElementById('finalScore').textContent = score.toLocaleString();
            document.getElementById('finalCombo').textContent = maxCombo;
            document.getElementById('gameOverScreen').style.display = 'block';
            
            if (isMobile && navigator.vibrate) {
                navigator.vibrate([500, 200, 500, 200, 1000]);
            }
        }

        function restartGame() {
            console.log('Restarting game');
            document.getElementById('gameOverScreen').style.display = 'none';
            achievements.clear();
            startGame();
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                showMessage("‚è∏Ô∏è GAME PAUSED ‚è∏Ô∏è", 99999);
                document.querySelector('.pause-btn').textContent = '‚ñ∂Ô∏è';
            } else if (gameState === 'paused') {
                gameState = 'playing';
                stateMessageTimer = 0;
                document.querySelector('.pause-btn').textContent = '‚è∏Ô∏è';
                lastTime = performance.now();
                gameLoop();
            }
        }

        // Event listeners with iOS optimizations
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') togglePause();
            e.preventDefault();
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Enhanced iOS touch handling
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());
        
        // Prevent iOS zoom and context menu
        document.addEventListener('touchstart', function (e) {
            if (e.touches.length > 1) e.preventDefault();
        }, { passive: false });
        
        document.addEventListener('contextmenu', e => e.preventDefault());

        // iOS double-tap zoom prevention
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = Date.now();
            if (now - lastTouchEnd <= 300) event.preventDefault();
            lastTouchEnd = now;
        }, false);

        // iOS viewport change handling
        if (isiOS && window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
        }

        // iOS orientation change handling
        window.addEventListener('orientationchange', function() {
            setTimeout(() => {
                resizeCanvas();
                if (gameState === 'playing') {
                    // Force a render update
                    requestAnimationFrame(() => {
                        // Empty frame to trigger repaint
                    });
                }
            }, 100);
        });

        // iOS web app status bar handling
        if (isiOS && window.navigator.standalone) {
            document.body.style.paddingTop = '44px'; // iOS status bar height
        }

        // Initialize on load
        initGame();
        
        // Auto-detect mobile controls
        const shouldUseMobile = isMobile || window.innerWidth <= 768 || window.innerHeight < 500;
        if (shouldUseMobile) {
            document.querySelectorAll('.desktop-controls').forEach(el => el.style.display = 'none');
            document.querySelectorAll('.mobile-controls-text').forEach(el => el.style.display = 'block');
            const mobileControlsDiv = document.querySelector('.mobile-controls');
            if (mobileControlsDiv) mobileControlsDiv.style.display = 'block';
            
            // Lock orientation if possible
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {
                    console.log('Screen orientation lock not supported');
                });
            }
        }

        // CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
